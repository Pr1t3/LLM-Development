{
    "1568. Minimum Number of Days to Disconnect Island": {
        "problem": "You are given an `m x n` binary grid `grid` where `1` represents land and `0` represents water. An island is a maximal 4\\-directionally (horizontal or vertical) connected group of `1`'s.\n",
        "explanation": "Algorithm\n#### Intuition\n\n\nAn articulation point is a cell that will split an island in two when it is changed from land to water. If a given grid has an articulation point, we can disconnect the island in one day. Tarjan's algorithm efficiently finds articulation points in a graph.\n\n\nThe algorithm uses three key pieces of information for each node (cell): discovery time, lowest reachable time, and parent. The discovery time is when a node is first visited during the DFS. The lowest reachable time is the minimum discovery time of any node that can be reached from the subtree rooted at the current node, including the current node itself. The parent is the node from which the current node was discovered during the DFS.\n\n\nA node can be an articulation point in two cases:\n\n\n1. A non\\-root node is an articulation point if it has a child whose lowest reachable time is greater than or equal to the node's discovery time. This condition means that the child (and its subtree) cannot reach any ancestor of the current node without going through the current node, making it critical for connectivity.\n2. The root node of the DFS tree is an articulation point if it has more than one child. Removing the root would disconnect these children from each other.\n\n\nIf no articulation points are found, the grid cannot be disconnected by removing a single land cell. In that case, we return 2\\.\n\n\n#### Algorithm\n\n\n* Define a constant array `DIRECTIONS` that contains the directions for moving right, down, left, and up.\n\n\nMain method `minDays`:\n\n\n* Set `rows` and `cols` as the number of rows and columns in the `grid`.\n* Initialize an `ArticulationPointInfo` object `apInfo` with `hasArticulationPoint` set to `false` and `time` set to `0`.\n* Initialize variables:\n\t+ `landCells` to count the number of land cells in the grid.\n\t+ `islandCount` to count the number of islands in the grid.\n* Initialize arrays `discoveryTime`, `lowestReachable`, and `parentCell` with default values of `-1`. These arrays store information about each cell during DFS traversal.\n* Loop through each cell `(i, j)` of the `grid`:\n\t+ If the cell is land (`1`):\n\t\t- Increment the `landCells` count.\n\t\t- If the cell has not been visited (`discoveryTime[i][j]` \\= `-1`):\n\t\t\t* Call `findArticulationPoints` on `(i, j)` to find if articulation point exists.\n\t\t\t* Increment `islandCount`.\n* If there is zero or more than one island, return `0`\n* If there is only one land cell, return `1`.\n* If there is an articulation point, return `1`.\n* Otherwise, return `2`.\n\n\nHelper method `findArticulationPoints`:\n\n\n* Define a method `findArticulationPoints` with parameters: `grid`, the `row` and `col` indices, `discoveryTime`, `lowestReachable`, `parentCell`, and `apInfo`.\n* Set `rows` and `cols` as the number of rows and columns in the `grid`.\n* Set `discoveryTime` of the current cell to `apInfo.time`.\n* Increment the `time` in `apInfo`.\n* Set the `lowestReachable` time of the current cell to its `discoveryTime`.\n* Initialize a variable `children` to count the number of child nodes in the DFS tree.\n* To explore adjacent cells, loop through each `direction` in `DIRECTIONS`:\n\t+ Calculate `newRow` as `row + direction[0]`.\n\t+ Calculate `newCol` as `col + direction[1]`.\n\t+ If `(newRow, newCol)` is a valid cell:\n\t\t- If the `discoveryTime` of the new cell is `-1`:\n\t\t\t* Increment `children`.\n\t\t\t* Set the `parentCell` of the new cell to the current cell.\n\t\t\t* Recursively call `findArticulationPoints` for the new cell.\n\t\t\t* Update the `lowestReachable` time for the current cell to the minimum of `lowestReachable[row][col]` and `lowestReachable[newRow][newCol]`.\n\t\t\t* If `lowestReachable` of `(newRow, newCol)` is greater than or equal to `discoveryTime` of `(row, col)`, and `(row, col)` has a parent:\n\t\t\t\t+ Set `hasArticulationPoint` of `apInfo` to `true`.\n\t\t\t* Else if `(newRow, newCol)` is not the parent of `(row, col)`:\n\t\t\t\t+ Set `lowestReachable` time of `(row, col)` to the minimum of `lowestReachable[row][col]` and `discoveryTime[newRow][newCol]`.\n* Check if `(row, col)` is the root of the DFS tree and has more than 1 `children`:\n\t+ Set `hasArticulationPoint` of `apInfo` to `true`.\n\n\nHelper method `isValidLandCell`:\n\n\n* Define a method `isValidLandCell` with parameters: `grid`, and the `row` and `col` indices.\n* Return `true` if the given cell is within the bounds of the grid and is a land cell (`1`).\n* Else, return `false`.\n\n\nHelper class `ArticulationPointInfo`:\n\n\n* Define a class `ArticulationPointInfo` with fields: `hasArticulationPoint` and `time`.\n* Override the default constructor to initialize `hasArticulationPoint` and `time`.\n\n\n#### \n\n",
        "solution": "```python\nclass Solution:\n    def minDays(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n\n        def _count_islands():\n            visited = set()\n            count = 0\n            for i in range(rows):\n                for j in range(cols):\n                    if grid[i][j] == 1 and (i, j) not in visited:\n                        _explore_island(i, j, visited)\n                        count += 1\n            return count\n\n        def _explore_island(i, j, visited):\n            if (\n                i < 0\n                or i >= rows\n                or j < 0\n                or j >= cols\n                or grid[i][j] == 0\n                or (i, j) in visited\n            ):\n                return\n            visited.add((i, j))\n            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                _explore_island(i + di, j + dj, visited)\n\n        # Check if already disconnected\n        if _count_islands() != 1:\n            return 0\n\n        # Check if can be disconnected in 1 day\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n\n\n                        return 1\n                    grid[i][j] = 1\n\n        # If can't be disconnected in 0 or 1 day, return 2\n        return 2\n```"
    },
    "1. Two Sum": {
        "problem": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n",
        "explanation": "Algorithm\nIt turns out we can do it in one\\-pass. While we are iterating and inserting elements into the hash table, we also look back to check if current element's complement already exists in the hash table. If it exists, we have found a solution and return the indices immediately.\n\n\n",
        "solution": "```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]\n```"
    },
    "2. Add Two Numbers": {
        "problem": "You are given two non\\-empty linked lists representing two non\\-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n",
        "explanation": "Algorithm\nJust like how you would sum two numbers on a piece of paper, we begin by summing the least\\-significant digits, which is the head of l1 and l2. Since each digit is in the range of 0â€¦9, summing two digits may \"overflow\". For example 5\\+7\\=12. In this case, we set the current digit to 2 and bring over the carry\\=1 to the next iteration. carry must be either 0 or 1 because the largest possible sum of two digits (including the carry) is 9\\+9\\+1\\=19.\n\n\nThe pseudocode is as following:\n\n\n* Initialize current node to dummy head of the returning list.\n* Initialize carry to 0.\n* Loop through lists l1 and l2 until you reach both ends and carry is 0.\n\t+ Set x to node l1's value. If l1 has reached the end of l1, set to 0.\n\t+ Set y to node l2's value. If l2 has reached the end of l2, set to 0.\n\t+ Set sum\\=x\\+y\\+carry.\n\t+ Update carry\\=sum/10.\n\t+ Create a new node with the digit value of (summod10) and set it to current node's next, then advance current node to next.\n\t+ Advance both l1 and l2.\n* Return dummy head's next node.\n\n\nNote that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.\n\n\nTake extra caution of the following cases:\n\n\n\n\n| Test case | Explanation |\n| --- | --- |\n| l1\\=\\[0,1]l2\\=\\[0,1,2] | When one list is longer than the other. |\n| l1\\=\\[]l2\\=\\[0,1] | When one list is null, which means an empty list. |\n| l1\\=\\[9,9]l2\\=\\[1] | The sum could have an extra carry of one at the end, which is easy to forget. |\n\n\n",
        "solution": "```python\nclass Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummyHead = ListNode(0)\n        curr = dummyHead\n        carry = 0\n        while l1 != None or l2 != None or carry != 0:\n            l1Val = l1.val if l1 else 0\n            l2Val = l2.val if l2 else 0\n            columnSum = l1Val + l2Val + carry\n            carry = columnSum // 10\n            newNode = ListNode(columnSum % 10)\n            curr.next = newNode\n            curr = newNode\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummyHead.next\n```"
    },
    "3. Longest Substring Without Repeating Characters": {
        "problem": "Given a string `s`, find the length of the longest substring without repeating characters.\n",
        "explanation": "Approach 1 \\- Set\n1. We use a set (`charSet`) to keep track of unique characters in the current substring.\n2. We maintain two pointers, `left` and `right`, to represent the boundaries of the current substring.\n3. The `maxLength` variable keeps track of the length of the longest substring encountered so far.\n4. We iterate through the string using the `right` pointer.\n5. If the current character is not in the set (`charSet`), it means we have a new unique character.\n6. We insert the character into the set and update the `maxLength` if necessary.\n7. If the character is already present in the set, it indicates a repeating character within the current substring.\n8. In this case, we move the `left` pointer forward, removing characters from the set until the repeating character is no longer present.\n9. We insert the current character into the set and continue the iteration.\n10. Finally, we return the `maxLength` as the length of the longest substring without repeating characters.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        n = len(s)\n        maxLength = 0\n        maxLength = 0\n        charSet = set()\n        charSet = set()\n        left = 0\n        left = 0\n        \n        for right in range(n):\n        for right in range(n):\n            if s[right] not in charSet:\n            if s[right] not in charSet:\n                charSet.add(s[right])\n                charSet.add(s[right])\n                maxLength = max(maxLength, right - left + 1)\n                maxLength = max(maxLength, right - left + 1)\n            else:\n            else:\n                while s[right] in charSet:\n                while s[right] in charSet:\n                    charSet.remove(s[left])\n                    charSet.remove(s[left])\n                    left += 1\n                    left += 1\n                charSet.add(s[right])\n                charSet.add(s[right])\n        \n        return maxLength\n        return maxLength\n\n```"
    },
    "4. Median of Two Sorted Arrays": {
        "problem": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.\n",
        "explanation": "Algorithm\n1. Assuming `nums1` to be the smaller array (If `nums2` is smaller, we can swap them). Let `m, n` represent the size of `nums1` and `nums2`, respectively.\n2. Define the search space for the partitioning index `partitionA` by setting boundaries as `left = 0` and `right = m`.\n3. While `left <= right` holds, do the following.\n4. Compute the partition index of `nums1` as `partitionA = (left + right) / 2`. Consequently, the partition index of `nums2` is `(m + n + 1) / 2 - partitionA`.\n5. Obtain the edge elements:\n\n\n\t* Determine the maximum value of the section `A_left` as `maxLeftA = nums1[partitionA - 1]`. If `partitionA - 1 < 0`, set it as `maxLeftA = float(-inf)`.\n\t* Determine the minimum value of the section `A_right` as `minRightA = nums1[partitionA]`. If `partitionA >= m`, set it as `minRightA = float(inf)`.\n\t* Determine the maximum value of the section `B_left` as `maxLeftB = nums2[partitionB - 1]`. If `partitionB - 1 < 0`, set it as `maxLeftB = float(-inf)`.\n\t* Determine the maximum value of the section `B_right` as `minRightB = nums2[partitionB]`. If `partitionB >= n`, set it as `minRightB = float(inf)`.\n6. Compare and recalculate: Compare `maxLeftA` with `minRightB` and `maxLeftB` with `minRightA`.\n\n\n\t* If `maxLeftA > minRightB`, it means the `maxLeftA` is too large to be in the smaller half, so we update `right = partitionA - 1` to move to the left half of the search space.\n\t* If `maxLeftB > minRightA`, it means that we are too far on the left side for `partitionA` and we need to go to the right half of the search space by updating `left = partitionA + 1`.Repeat step 4\\.\n7. When both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` are true:\n\n\n\t* If `(m + n) % 2 = 0`, the median value is the average of the maximum value of the smaller half and the minimum value of the larger half, given by `answer = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2`.\n\t* Otherwise, the median value is the maximum value of the smaller half, given by `answer = max(maxLeftA, maxLeftB)`.\n\n\n#### \n\n",
        "solution": "```python\nclass Solution:\n    def findMedianSortedArrays(\n        self, nums1: List[int], nums2: List[int]\n    ) -> float:\n        m, n = len(nums1), len(nums2)\n        p1, p2 = 0, 0\n\n        # Get the smaller value between nums1[p1] and nums2[p2].\n        def get_min():\n            nonlocal p1, p2\n            if p1 < m and p2 < n:\n                if nums1[p1] < nums2[p2]:\n                    ans = nums1[p1]\n                    p1 += 1\n                else:\n                    ans = nums2[p2]\n                    p2 += 1\n            elif p2 == n:\n                ans = nums1[p1]\n                p1 += 1\n            else:\n                ans = nums2[p2]\n                p2 += 1\n            return ans\n\n        if (m + n) % 2 == 0:\n            for _ in range((m + n) // 2 - 1):\n                _ = get_min()\n            return (get_min() + get_min()) / 2\n        else:\n            for _ in range((m + n) // 2):\n                _ = get_min()\n            return get_min()\n```"
    },
    "5. Longest Palindromic Substring": {
        "problem": "Given a string `s`, return the longest palindromic substring in `s`.\n",
        "explanation": "Algorithm\nBelieve it or not, this problem can be solved in linear time.\n\n\n[Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) finds the longest palindromic substring in O(n) time and space.\n\n\nNote: this algorithm is completely out of scope for coding interviews. Because of this, we will not be talking about the algorithm in detail. This approach has been included for the sake of completeness and for those who are curious about algorithms beyond the scope of interviews.\n\n\nIf you wish to learn more about Manacher's algorithm, please reference the above link.\n\n\n",
        "solution": "```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        def check(i, j):\n            left = i\n            right = j - 1\n\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n\n                left += 1\n                right -= 1\n\n            return True\n\n        for length in range(len(s), 0, -1):\n            for start in range(len(s) - length + 1):\n                if check(start, start + length):\n                    return s[start : start + length]\n\n        return \"\"\n```"
    },
    "6. Zigzag Conversion": {
        "problem": "The string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n",
        "explanation": "Approach\nLet's think about this example.\n\n\n\n```\ns = \"abcdefghi\", numRows = 4\n```\n\nIn this case, we put the characters of `s` like this.\n\n\n\n```\n1 a     g â†’ ag\n2 b   f h â†’ bfh\n3 c e   i â†’ cei\n4 d       â†’ d\n```\n\n\n```\nreturn \"agbfhceid\"\n```\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n        if numRows == 1 or numRows >= len(s):\n            return s\n            return s\n\n        idx, d = 0, 1\n        idx, d = 0, 1\n        rows = [[] for _ in range(numRows)]\n        rows = [[] for _ in range(numRows)]\n\n        for char in s:\n        for char in s:\n            rows[idx].append(char)\n            rows[idx].append(char)\n            if idx == 0:\n            if idx == 0:\n                d = 1\n                d = 1\n            elif idx == numRows - 1:\n            elif idx == numRows - 1:\n                d = -1\n                d = -1\n            idx += d\n            idx += d\n\n        for i in range(numRows):\n        for i in range(numRows):\n            rows[i] = ''.join(rows[i])\n            rows[i] = ''.join(rows[i])\n\n        return ''.join(rows)           return ''.join(rows)   \n```"
    },
    "7. Reverse Integer": {
        "problem": "Given a signed 32\\-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32\\-bit integer range `[-231, 231 - 1]`, then return `0`.\n",
        "explanation": "Approach\nThis question doesn't allow us to use 64\\-bit integer, so the first two solution are wrong but I think it's good to have multiple solutions for real interview. I'll show you three ways to solve this question.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def reverse(self, x: int) -> int:\n    def reverse(self, x: int) -> int:\n        res = 0\n        res = 0\n        if x < 0:\n        if x < 0:\n            res = int(str(x)[1:][::-1]) * -1\n            res = int(str(x)[1:][::-1]) * -1\n        else:\n        else:\n            res = int(str(x)[::-1])\n            res = int(str(x)[::-1])\n        \n        if res > 2 ** 31 - 1 or res < -2 ** 31:\n        if res > 2 ** 31 - 1 or res < -2 ** 31:\n            return 0\n            return 0\n        \n        return res        return res\n```"
    },
    "8. String to Integer (atoi)": {
        "problem": "Implement the `myAtoi(string s)` function, which converts a string to a 32\\-bit signed integer.\n",
        "explanation": "Approach\n1. **Handling Empty String:**\n\n\n\t* `if (s.length() == 0)`: Checks if the input string `s` is empty. If so, it returns 0 as there's no numerical content.\n2. **Skipping Leading Whitespaces:**\n\n\n\t* `while (i < s.length() && s.charAt(i) == ' ')`: The `while` loop iterates through characters (`s.charAt(i)`) as long as they are whitespaces (' ') and the index `i` is within the string bounds. This skips any leading whitespaces before the potential number.\n3. **Handling Optional Sign:**\n\n\n\t* `if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+'))`: Checks if the first non\\-whitespace character (`s.charAt(i)`) is a sign ('\\-' or '\\+').\n\t\t+ `if (s.charAt(i) == '-')`: If it's a minus sign, the `sign` variable is set to \\-1 to indicate a negative number.\n\t\t+ `i++`: Increments the index `i` to move past the optional sign.\n4. **Converting Digits:**\n\n\n\t* `while (i < s.length() && s.charAt(i) - '0' <= 9 && s.charAt(i) - '0' >= 0)`: The `while` loop iterates through characters as long as they are valid digits (between '0' and '9') and the index `i` is within the string bounds.\n\t\t+ `int digit = s.charAt(i) - '0'`: Converts the current character (assumed to be a digit) to its corresponding integer value by subtracting the ASCII value of '0'.\n\t\t+ **Overflow Handling:**\n\t\t\t- `if (ans > max / 10 || (ans == max / 10 && digit > max % 10))`: This condition checks for potential overflow situations for positive numbers. It compares the current accumulated value (`ans`) with the maximum integer value (`max`) divided by 10 (considering the next digit) and the remainder (`max % 10`). If `ans` is already greater than the maximum divided by 10, or if `ans` is equal to the maximum divided by 10 and the current digit (`digit`) is greater than the remainder, it signifies overflow.\n\t\t\t\t* `return (sign == 1) ? max : min;`: In case of overflow, the code returns the maximum positive value (`max`) if the sign is positive (`sign == 1`) or the minimum negative value (`min`) if the sign is negative. This behavior is consistent with some C/C\\+\\+ library functions for string\\-to\\-integer conversion.\n\t\t+ `ans = ans * 10 + digit`: If no overflow, the current digit is incorporated into the accumulated value (`ans`) by multiplying it by 10 (shifting existing digits left) and adding the current digit.\n\t\t+ `i++`: Increments the index `i` to move to the next character for processing.\n5. **Returning the Result:**\n\n\n\t* `return ans * sign`: After processing all valid digits, the final `ans` is multiplied by the `sign` (1 for positive, \\-1 for negative) and returned as the converted integer value.\n\n\n",
        "solution": "```python\nclass Solution(object):\nclass Solution(object):\n    def myAtoi(self, s):\n    def myAtoi(self, s):\n        \"\"\"\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        ans = 0\n        ans = 0\n        i = 0\n        i = 0\n        sign = 1\n        sign = 1\n        max_int = 2**31 - 1\n        max_int = 2**31 - 1\n        min_int = -2**31\n        min_int = -2**31\n        \n        if len(s) == 0:\n        if len(s) == 0:\n            return 0\n            return 0\n        \n        # Remove leading whitespaces\n        # Remove leading whitespaces\n        while i < len(s) and s[i] == ' ':\n        while i < len(s) and s[i] == ' ':\n            i += 1\n            i += 1\n        \n        # Check for sign\n        # Check for sign\n        if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        if i < len(s) and (s[i] == '-' or s[i] == '+'):\n            if s[i] == '-':\n            if s[i] == '-':\n                sign = -1\n                sign = -1\n            i += 1\n            i += 1\n        \n        # Convert digits to integer\n        # Convert digits to integer\n        while i < len(s) and '0' <= s[i] <= '9':\n        while i < len(s) and '0' <= s[i] <= '9':\n            digit = ord(s[i]) - ord('0')\n            digit = ord(s[i]) - ord('0')\n            if ans > max_int // 10 or (ans == max_int // 10 and digit > max_int % 10):\n            if ans > max_int // 10 or (ans == max_int // 10 and digit > max_int % 10):\n                return max_int if sign == 1 else min_int\n                return max_int if sign == 1 else min_int\n            ans = ans * 10 + digit\n            ans = ans * 10 + digit\n            i += 1\n            i += 1\n        \n        return ans * sign        return ans * sign\n```"
    },
    "9. Palindrome Number": {
        "problem": "Given an integer `x`, return `true` if `x` is a palindrome, and `false` otherwise.\n",
        "explanation": "Explanation:\n1. We begin by performing an initial check. If the input number `x` is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return `false`.\n2. We initialize two variables:\n\n\n\t* `reversed`: This variable will store the reversed value of the number `x`.\n\t* `temp`: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\n3. We enter a loop that continues until `temp` becomes zero:\n\n\n\t* Inside the loop, we extract the last digit of `temp` using the modulo operator `%` and store it in the `digit` variable.\n\t* To reverse the number, we multiply the current value of `reversed` by 10 and add the extracted `digit`.\n\t* We then divide `temp` by 10 to remove the last digit and move on to the next iteration.\n4. Once the loop is completed, we have reversed the entire number. Now, we compare the reversed value `reversed` with the original input value `x`.\n\n\n\t* If they are equal, it means the number is a palindrome, so we return `true`.\n\t* If they are not equal, it means the number is not a palindrome, so we return `false`.\n\n\nThe code uses a `long long` data type for the `reversed` variable to handle potential overflow in case of large input numbers.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n        if x < 0:\n            return False\n            return False\n\n        reversed_num = 0\n        reversed_num = 0\n        temp = x\n        temp = x\n\n        while temp != 0:\n        while temp != 0:\n            digit = temp % 10\n            digit = temp % 10\n            reversed_num = reversed_num * 10 + digit\n            reversed_num = reversed_num * 10 + digit\n            temp //= 10\n            temp //= 10\n\n        return reversed_num == x\n        return reversed_num == x\n\n```"
    },
    "10. Regular Expression Matching": {
        "problem": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n",
        "explanation": "Algorithm\nWe proceed with the same recursion as in [Approach 1](#approach-1-recursion), except because calls will only ever be made to `match(text[i:], pattern[j:])`, we use dp(i,Â j) to handle those calls instead, saving us expensive string\\-building operations and allowing us to cache the intermediate results.\n\n\n*Top\\-Down Variation*\n\n\n\n*Bottom\\-Up Variation*\n\n\n\n**Complexity Analysis**\n\n\n* Time Complexity: Let T,P be the lengths of the text and the pattern respectively. The work for every call to `dp(i, j)` for i\\=0,...,T; j\\=0,...,P is done once, and it is O(1) work. Hence, the time complexity is O(TP).\n* Space Complexity: The only memory we use is the O(TP) boolean entries in our cache. Hence, the space complexity is O(TP).\n\n\\</ul",
        "solution": "```python\ndef match(text, pattern):\n    if not pattern:\n        return not text\n    first_match = bool(text) and pattern[0] in {text[0], \".\"}\n    return first_match and match(text[1:], pattern[1:])\n```"
    },
    "11. Container With Most Water": {
        "problem": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n",
        "explanation": "Explanation:\n1. Initialize the variables:\n\n\n\t* `left` to represent the left pointer, starting at the beginning of the container (index 0\\).\n\t* `right` to represent the right pointer, starting at the end of the container (index `height.size() - 1`).\n\t* `maxArea` to keep track of the maximum area found, initially set to 0\\.\n2. Enter a loop using the condition `left < right`, which means the pointers have not crossed each other yet.\n3. Calculate the current area:\n\n\n\t* Use the `min` function to find the minimum height between the `left` and `right` pointers.\n\t* Multiply the minimum height by the width, which is the difference between the indices of the pointers: `(right - left)`.\n\t* Store this value in the `currentArea` variable.\n4. Update the maximum area:\n\n\n\t* Use the `max` function to compare the `currentArea` with the `maxArea`.\n\t* If the `currentArea` is greater than the `maxArea`, update `maxArea` with the `currentArea`.\n5. Move the pointers inward: (Explained in detail below)\n\n\n\t* Check if the height at the `left` pointer is smaller than the height at the `right` pointer.\n\t* If so, increment the `left` pointer, moving it towards the center of the container.\n\t* Otherwise, decrement the `right` pointer, also moving it towards the center.\n6. Repeat steps 3 to 5 until the pointers meet (`left >= right`), indicating that all possible containers have been explored.\n7. Return the `maxArea`, which represents the maximum area encountered among all the containers.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n    def maxArea(self, height: List[int]) -> int:\n        left = 0\n        left = 0\n        right = len(height) - 1\n        right = len(height) - 1\n        maxArea = 0\n        maxArea = 0\n\n        while left < right:\n        while left < right:\n            currentArea = min(height[left], height[right]) * (right - left)\n            currentArea = min(height[left], height[right]) * (right - left)\n            maxArea = max(maxArea, currentArea)\n            maxArea = max(maxArea, currentArea)\n\n            if height[left] < height[right]:\n            if height[left] < height[right]:\n                left += 1\n                left += 1\n            else:\n            else:\n                right -= 1\n                right -= 1\n\n        return maxArea        return maxArea\n```"
    },
    "13. Roman to Integer": {
        "problem": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n",
        "explanation": "Explanation:\n1. The unordered map `m` is created and initialized with mappings between Roman numeral characters and their corresponding integer values. For example, 'I' is mapped to 1, 'V' to 5, 'X' to 10, and so on.\n2. The variable `ans` is initialized to 0\\. This variable will accumulate the final integer value of the Roman numeral string.\n3. The for loop iterates over each character in the input string `s`.  \n\n**For the example \"IX\":**\n\n\n\t* When `i` is 0, the current character `s[i]` is 'I'. Since there is a next character ('X'), and the value of 'I' (1\\) is less than the value of 'X' (10\\), the condition `m[s[i]] < m[s[i+1]]` is true. In this case, we subtract the value of the current character from `ans`.\n\t\n\t\n\t`ans -= m[s[i]];`  \n\t\n\t`ans -= m['I'];`  \n\t\n\t`ans -= 1;`  \n\t\n\t`ans` becomes \\-1\\.\n\t* When `i` is 1, the current character `s[i]` is 'X'. This is the last character in the string, so there is no next character to compare. Since there is no next character, we don't need to evaluate the condition. In this case, we add the value of the current character to `ans`.\n\t\n\t\n\t`ans += m[s[i]];`  \n\t\n\t`ans += m['X'];`  \n\t\n\t`ans += 10;`  \n\t\n\t`ans` becomes 9\\.**For the example \"XI\":**\n\n\n\t* When `i` is 0, the current character `s[i]` is 'X'. Since there is a next character ('I'), and the value of 'X' (10\\) is greater than the value of 'I' (1\\), the condition `m[s[i]] < m[s[i+1]]` is false. In this case, we add the value of the current character to `ans`.\n\t\n\t\n\t`ans += m[s[i]];`  \n\t\n\t`ans += m['X'];`  \n\t\n\t`ans += 10;`  \n\t\n\t`ans` becomes 10\\.\n\t* When `i` is 1, the current character `s[i]` is 'I'. This is the last character in the string, so there is no next character to compare. Since there is no next character, we don't need to evaluate the condition. In this case, we add the value of the current character to `ans`.\n\t\n\t\n\t`ans += m[s[i]];`  \n\t\n\t`ans += m['I'];`  \n\t\n\t`ans += 1;`  \n\t\n\t`ans` becomes 11\\.\n4. After the for loop, the accumulated value in `ans` represents the integer conversion of the Roman numeral string, and it is returned as the result.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n    def romanToInt(self, s: str) -> int:\n        m = {\n        m = {\n            'I': 1,\n            'I': 1,\n            'V': 5,\n            'V': 5,\n            'X': 10,\n            'X': 10,\n            'L': 50,\n            'L': 50,\n            'C': 100,\n            'C': 100,\n            'D': 500,\n            'D': 500,\n            'M': 1000\n            'M': 1000\n        }\n        }\n        \n        ans = 0\n        ans = 0\n        \n        for i in range(len(s)):\n        for i in range(len(s)):\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n            if i < len(s) - 1 and m[s[i]] < m[s[i+1]]:\n                ans -= m[s[i]]\n                ans -= m[s[i]]\n            else:\n            else:\n                ans += m[s[i]]\n                ans += m[s[i]]\n        \n        return ans        return ans\n```"
    },
    "14. Longest Common Prefix": {
        "problem": "Write a function to find the longest common prefix string amongst an array of strings.\n",
        "explanation": "Algorithm\nThe only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from \\[S1â€‹â€¦Snâ€‹] strings. Then find the prefix of query string `q` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.\n\n\n![Finding the longest common prefix using Trie](https://leetcode.com/media/original_images/14_lcp_trie.png)\n\n\n*Figure 4\\. Finding the longest common prefix of strings using Trie*\n\n\n#### \n\n",
        "solution": "```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if len(strs) == 0:\n            return \"\"\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while strs[i].find(prefix) != 0:\n                prefix = prefix[0 : len(prefix) - 1]\n                if prefix == \"\":\n                    return \"\"\n        return prefix\n```"
    },
    "15. 3Sum": {
        "problem": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n",
        "explanation": "Approach\nI think it's tough to manage 3 indices at the same time, so my strategy is to fix `i`.\n\n\n\n```\nInput: nums = [-1,0,1,2,-1,-4]\n```\n\n\n```\n[-1,0,1,2,-1,-4]\n  i\n```\n\nWe fix `i` at index `0` at first. Then we have other two indices `j` and `k`. `j` starts from `i + 1` and `k` starts from the last index.\n\n\n\n```\n[-1,0,1,2,-1,-4]\n  i j         k\n```\n\nBasically, we calculate a total of 3 numbers, then if the total is `0`, that is one of target triplets.\n\n\nBut there are many cases where the total is not `0`. In that case we should move `j` or `k` to the next, because we fix `i` at index `0` at first. All calculations in a loop this time, we must use `i` number.\n\n\n\n\n---\n\n\nQuestion\n\n\nHow can we decide and move `j` or `k` to the next index?\n\n\n\n\n---\n\n\nMy strategy is to sort input array, so that we can decide which index we should move.\n\n\n\n```\n[-1,0,1,2,-1,-4]\nâ†“\n[-4,-1,-1,0,1,2]\n  i  j        k\n```\n\n\n\n---\n\n\nâ­ï¸ Points\n\n\n* Why do we need to sort input array?\n\n\nThat's because if the total is greater than `0`, we want small total next time. In that case, we should move `k` to the next because input array is sorted, we are sure that if `k` move to left index, we will get small total compared with the current total.\n\n\nOn the other hand, if the total is smaller than `0`, we want big total next time. In that case we should move `j` to the right index to get big total.\n\n\n\n\n---\n\n\nLet's see one by one.\n\n\n\n```\n[-4,-1,-1,0,1,2]\n  i  j        k\n\nnums[i] + nums[j] + nums[k] = -3\n```\n\nWe should move `j` to the next.\n\n\nI'll speed up\n\n\n\n```\n[-4,-1,-1,0,1,2]\n  i     j     k\n\nnums[i] + nums[j] + nums[k] = -3\n\nj moves to the next\n\n[-4,-1,-1,0,1,2]\n  i       j   k\n\nnums[i] + nums[j] + nums[k] = -2\n\nj moves to the next\n\n[-4,-1,-1,0,1,2]\n  i         j k\n\nnums[i] + nums[j] + nums[k] = -1\n\nj moves to the next\n\n[-4,-1,-1,0,1,2]\n  i           k\n              j\n```\n\nNow `j` and `k` are the same index, so we stop iteration. For this question, we have to find all triplets.\n\n\nNext, we fix `i` at index `1`. `j` starts from `i + 1` and `k` starts from the last index.\n\n\n\n```\n[-4,-1,-1,0,1,2]\n     i  j     k\n```\n\nWe do the same thing.\n\n\n\n```\n[-4,-1,-1,0,1,2]\n     i  j     k\n\nnums[i] + nums[j] + nums[k] = 0\n```\n\nWe found total `0` and 3 indices are different, so current combination meets condition the description says. That is one of answers.\n\n\n\n```\nres = [[-1,-1,2]]\n```\n\nWhen we found the target triplet, there are several ways to move pointers. I think easiest way is to move `j` once.\n\n\nBut there is problem. What if the next number is the same as current number like this.\n\n\n\n```\n[-4,-1,-1,-1,1,2]\n     i    j   k\n\nI changed 0 to -1 at index 3.\n```\n\nIn this case, we found \\[\\-1,\\-1,2] again. It's the target triplet but the description says \"No duplicate\".\n\n\nTo avoid this, when we found one of the target triplets, we move `j` once but we check the number after we move `j`. If the number is the same previous number, we continue to move `j` until we find differnt number, so that we can avoid duplicate combination.\n\n\n\n\n---\n\n\nâ­ï¸ Points\n\n\nMove `j` until we find different number when we find one of the target triplets.\n\n\n\n\n---\n\n\nLet's go back to main topic.\n\n\n\n```\n[-4,-1,-1,0,1,2]\n     i    j   k\n\nnums[i] + nums[j] + nums[k] = 1\n```\n\nNow the total is greater than `0`. We should move `k` to the left index to get small total.\n\n\n\n```\n[-4,-1,-1,0,1,2]\n     i    j k\n\nnums[i] + nums[j] + nums[k] = 0\n```\n\nWe found a new triplets that meets the conditions.\n\n\n\n```\nres = [[-1,-1,2], [-1,0,1]]\n```\n\nThis example is example 1 in the description. It says those two combinations are return value, so I stop explanation.\n\n\nAfter that, we do the same thing. `j` and `k` are the same index, so we fix `i` at index `2`. `j` starts from `i + 1` and `k` starts from the last index.\n\n\n\n```\n[-4,-1,-1,0,1,2]\n        i j   k\n```\n\nIn the end,\n\n\n\n```\nreturn [[-1,-1,2], [-1,0,1]]\n```\n\nEasy!ðŸ˜„  \n\nLet's see solution codes and step by step algorithm.\n\n\n\n\n---\n\n\nThis question is similar to Two Sum â…¡ question.\n\n\n\n\n\n---\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        res = []\n        nums.sort()\n        nums.sort()\n\n        for i in range(len(nums)):\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n                continue\n            \n            j = i + 1\n            j = i + 1\n            k = len(nums) - 1\n            k = len(nums) - 1\n\n            while j < k:\n            while j < k:\n                total = nums[i] + nums[j] + nums[k]\n                total = nums[i] + nums[j] + nums[k]\n\n                if total > 0:\n                if total > 0:\n                    k -= 1\n                    k -= 1\n                elif total < 0:\n                elif total < 0:\n                    j += 1\n                    j += 1\n                else:\n                else:\n                    res.append([nums[i], nums[j], nums[k]])\n                    res.append([nums[i], nums[j], nums[k]])\n                    j += 1\n                    j += 1\n\n                    while nums[j] == nums[j-1] and j < k:\n                    while nums[j] == nums[j-1] and j < k:\n                        j += 1\n                        j += 1\n        \n        return res        return res\n```"
    },
    "17. Letter Combinations of a Phone Number": {
        "problem": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n",
        "explanation": "Approach \\- Backtracking\n1. **Initialize a Mapping**: Create a dictionary that maps each digit from 2 to 9 to their corresponding letters on a telephone's buttons. For example, the digit '2' maps to \"abc,\" '3' maps to \"def,\" and so on.\n2. **Base Case**: Check if the input string `digits` is empty. If it is, return an empty list, as there are no combinations to generate.\n3. **Recursive Backtracking**:\n\n\n\t* **Define Recursive Function**: Create a recursive function, `backtrack`, that will be used to explore all possible combinations. It takes two parameters: `combination`, which holds the current combination of letters, and `next_digits`, which holds the remaining digits to be explored.\n\t* **Termination Condition**: If `next_digits` is empty, it means that all digits have been processed, so append the current `combination` to the result.\n\t* **Exploration**: If there are more digits to explore, take the first digit from `next_digits` and iterate over its corresponding letters in the mapping. For each letter, concatenate it to the current combination and recursively call the `backtrack` function with the new combination and the remaining digits.\n\t* **Example**: If the input is \"23\", the first recursive call explores all combinations starting with 'a', 'b', and 'c' (from '2'), and the next level of recursive calls explores combinations starting with 'd', 'e', 'f' (from '3'), building combinations like \"ad,\" \"ae,\" \"af,\" \"bd,\" \"be,\" etc.\n4. **Result**: Once the recursive exploration is complete, return the collected combinations as the final result. By using recursion, we ensure that all possible combinations are explored, and the result includes all valid letter combinations that the input digits can represent.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n        if not digits:\n            return []\n            return []\n\n        phone_map = {\n        phone_map = {\n            '2': 'abc',\n            '2': 'abc',\n            '3': 'def',\n            '3': 'def',\n            '4': 'ghi',\n            '4': 'ghi',\n            '5': 'jkl',\n            '5': 'jkl',\n            '6': 'mno',\n            '6': 'mno',\n            '7': 'pqrs',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '8': 'tuv',\n            '9': 'wxyz'\n            '9': 'wxyz'\n        }\n        }\n\n        def backtrack(combination, next_digits):\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n            if len(next_digits) == 0:\n                output.append(combination)\n                output.append(combination)\n            else:\n            else:\n                for letter in phone_map[next_digits[0]]:\n                for letter in phone_map[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n                    backtrack(combination + letter, next_digits[1:])\n\n        output = []\n        output = []\n        backtrack(\"\", digits)\n        backtrack(\"\", digits)\n        return output        return output\n```"
    },
    "18. 4Sum": {
        "problem": "Given an array `nums` of `n` integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:\n",
        "explanation": "Algorithm\n`twoSum` implementation here is almost the same as in [Two Sum: One\\-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table). The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result `res`.\n\n\n",
        "solution": "```python\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n\n        def kSum(nums: List[int], target: int, k: int) -> List[List[int]]:\n            res = []\n\n            # If we have run out of numbers to add, return res.\n            if not nums:\n                return res\n\n            # There are k remaining values to add to the sum. The\n            # average of these values is at least target // k.\n            average_value = target // k\n\n            # We cannot obtain a sum of target if the smallest value\n            # in nums is greater than target // k or if the largest\n            # value in nums is smaller than target // k.\n            if average_value < nums[0] or nums[-1] < average_value:\n                return res\n\n            if k == 2:\n                return twoSum(nums, target)\n\n            for i in range(len(nums)):\n                if i == 0 or nums[i - 1] != nums[i]:\n                    for subset in kSum(nums[i + 1 :], target - nums[i], k - 1):\n                        res.append([nums[i]] + subset)\n\n            return res\n\n        def twoSum(nums: List[int], target: int) -> List[List[int]]:\n            res = []\n            lo, hi = 0, len(nums) - 1\n\n            while lo < hi:\n                curr_sum = nums[lo] + nums[hi]\n\n\n                elif curr_sum > target or (\n                    hi < len(nums) - 1 and nums[hi] == nums[hi + 1]\n                ):\n                    hi -= 1\n                else:\n                    res.append([nums[lo], nums[hi]])\n                    lo += 1\n```"
    },
    "19. Remove Nth Node From End of List": {
        "problem": "Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.\n",
        "explanation": "Approach\nA challenging point of this question is that Linked List doesn't have index number, so we don't know which node is the last Nth node from the last.\n\n\nMy strategy is to create `dummy` pointer and create distance `dummy` pointer and `head` pointer.\n\n\n\n```\nInput: head = [1,2,3,4,5], n = 2\n```\n\n\n```\n[1,2,3,4,5]\n d   h\n r\n\nd = dummy\nh = head\nr = res (return value)\n```\n\nNow we move `dummy` and `head` at the same time until `head` is at the last node.\n\n\n\n```\n[1,2,3,4,5]\n   d   h\n r\n\n[1,2,3,4,5]\n     d   h\n r\n```\n\nThis example has `n = 2`, so we should remove  `node 4`. Luckily, we stop at `node 3` which is right before `node 4`. That is very important.\n\n\nWhy?\n\n\nThat's because if we stop right before target node, we can remove the target node like this.\n\n\n\n```\ndummy.next = dummy.next.next(= 5 in this case)\n```\n\nBut what if we stop at the target node.\n\n\n\n```\n[1,2,3,4,5]\n       d   h\n```\n\nIt's going to be tough to remove the target node. That's why it's important to stop right before the target node.\n\n\nBefore we return a new list, we have one more problem. How can we return whole new list? Because `head` pointer is now the last node and `dummy` pointer is pointing to `node 3`.\n\n\n\n```\n[1,2,3,4,5]\n     d   h\n r\n```\n\nThat's why at first we have `dummy` pointer and `result` pointer. The `result` pointer is still pointing to `node 1`.\n\n\nAll we have to do is just\n\n\n\n```\nreturn res.next\n```\n\n\n\n---\n\n\n\n\n\n---\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        res = ListNode(0, head)\n        res = ListNode(0, head)\n        dummy = res\n        dummy = res\n\n        for _ in range(n):\n        for _ in range(n):\n            head = head.next\n            head = head.next\n        \n        while head:\n        while head:\n            head = head.next\n            head = head.next\n            dummy = dummy.next\n            dummy = dummy.next\n        \n        dummy.next = dummy.next.next\n        dummy.next = dummy.next.next\n\n        return res.next        return res.next\n```"
    },
    "20. Valid Parentheses": {
        "problem": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n",
        "explanation": "Approach\nWe use `HashMap` and `Stack`. We know valid combination, so initialize the combination with `HashMap` before we iterate through the input string.\n\n\n\n```\nmapping = { \")\":\"(\", \"}\":\"{\", \"]\":\"[\" }\n```\n\n`Stack` has only open parentheses. When a close parenthesis comes, we use it as a key to find valid open parenthesis in the `mapping`. If the two parentheses(current parenthesis and the latest parenthesis in `Stack`) are not valid combination, we should return `False`.\n\n\nAt last, if `Stack` is empty, we should return `True`.\n\n\n\n\n---\n\n\n\n\n\n---\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def isValid(self, s: str) -> bool:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        stack = []\n        mapping = {\")\":\"(\", \"}\":\"{\", \"]\":\"[\"}\n        mapping = {\")\":\"(\", \"}\":\"{\", \"]\":\"[\"}\n\n        for char in s:\n        for char in s:\n            if char in mapping.values():\n            if char in mapping.values():\n                stack.append(char)\n                stack.append(char)\n            elif char in mapping.keys():\n            elif char in mapping.keys():\n                if not stack or mapping[char] != stack.pop():\n                if not stack or mapping[char] != stack.pop():\n                    return False\n                    return False\n        \n        return not stack        return not stack\n```"
    },
    "21. Merge Two Sorted Lists": {
        "problem": "You are given the heads of two sorted linked lists `list1` and `list2`.\n",
        "explanation": "Approach\nJust compare two values from `list 1` and `list 2`, then take the small value and create a new list.\n\n\nBut problem is that we can't return \"the head of the merged linked list\". So my strategy is to use dummy pointer which is always pointing to head node as a next node.\n\n\nI visualized the solution in the video. Please check it out!\n\n\n\n\n---\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        dummy = ListNode()\n        cur = dummy\n        cur = dummy\n\n        while list1 and list2:\n        while list1 and list2:\n            if list1.val > list2.val:\n            if list1.val > list2.val:\n                cur.next = list2\n                cur.next = list2\n                list2 = list2.next\n                list2 = list2.next\n            else:\n            else:\n                cur.next = list1\n                cur.next = list1\n                list1 = list1.next\n                list1 = list1.next\n            \n            cur = cur.next\n            cur = cur.next\n        \n        if list1:\n        if list1:\n            cur.next = list1\n            cur.next = list1\n        else:\n        else:\n            cur.next = list2\n            cur.next = list2\n        \n        return dummy.next        return dummy.next\n```"
    },
    "22. Generate Parentheses": {
        "problem": "Given `n` pairs of parentheses, write a function to generate all combinations of well\\-formed parentheses.\n",
        "explanation": "Approach\nLet's think about `n = 2`.\n\n\n\n```\nn = 2\n\nwell-formed parentheses\n()()\n(())\n```\n\nDid you learn something from the example?\n\n\nThinking time...\n\n\n...ðŸ˜©\n\n\n...ðŸ˜…\n\n\n...ðŸ˜ƒ\n\n\n\n\n---\n\n\nâ­ï¸ Points\n\n\nWe have open parentheses before close parentheses. That's why my strategy is to increase number of open parentheses until `n` at first, then increase number of close parentheses until `n`.\n\n\n\n\n---\n\n\n![ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ 2024-07-02 23.40.50.png](https://assets.leetcode.com/users/images/f0250381-4395-4073-ad33-55d7818d1e4f_1719931423.3694198.png)\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n    def generateParenthesis(self, n: int) -> List[str]:\n        res = []\n        res = []\n\n        def dfs(openP, closeP, s):\n        def dfs(openP, closeP, s):\n            if openP == closeP and openP + closeP == n * 2:\n            if openP == closeP and openP + closeP == n * 2:\n                res.append(s)\n                res.append(s)\n                return\n                return\n            \n            if openP < n:\n            if openP < n:\n                dfs(openP + 1, closeP, s + \"(\")\n                dfs(openP + 1, closeP, s + \"(\")\n            \n            if closeP < openP:\n            if closeP < openP:\n                dfs(openP, closeP + 1, s + \")\")\n                dfs(openP, closeP + 1, s + \")\")\n\n        dfs(0, 0, \"\")\n        dfs(0, 0, \"\")\n\n        return res        return res\n```"
    },
    "23. Merge k Sorted Lists": {
        "problem": "You are given an array of `k` linked\\-lists `lists`, each linked\\-list is sorted in ascending order.\n",
        "explanation": "Approach for this Problem:\n1. Define a function merge that takes two pointers to linked lists as input and merges them in a sorted manner.\n\n\n\t* a. Create a dummy node with a value of \\-1 and a temporary node pointing to it.\n\t* b. Compare the first node of the left and right linked lists, and append the smaller one to the temporary node.\n\t* c. Continue this process until either of the lists becomes empty.\n\t* d. Append the remaining nodes of the non\\-empty list to the temporary node.\n\t* e. Return the next node of the dummy node.\n2. Define a function mergeSort that takes three arguments \\- a vector of linked lists, a starting index, and an ending index. It performs merge sort on the linked lists from the starting index to the ending index.\n\n\n\t* a. If the starting index is equal to the ending index, return the linked list at that index.\n\t* b. Calculate the mid index and call mergeSort recursively on the left and right halves of the vector.\n\t* c. Merge the two sorted linked lists obtained from the recursive calls using the merge function and return the result.\n3. Define the main function mergeKLists that takes the vector of linked lists as input and returns a single sorted linked list.\n\n\n\t* a. If the input vector is empty, return a null pointer.\n\t* b. Call the mergeSort function on the entire input vector, from index 0 to index k\\-1, where k is the size of the input vector.\n\t* c. Return the merged linked list obtained from the mergeSort function call.\n4. End of algorithm.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def merge(self, left: ListNode, right: ListNode) -> ListNode:\n    def merge(self, left: ListNode, right: ListNode) -> ListNode:\n        dummy = ListNode(-1)\n        dummy = ListNode(-1)\n        temp = dummy\n        temp = dummy\n        while left and right:\n        while left and right:\n            if left.val < right.val:\n            if left.val < right.val:\n                temp.next = left\n                temp.next = left\n                temp = temp.next\n                temp = temp.next\n                left = left.next\n                left = left.next\n            else:\n            else:\n                temp.next = right\n                temp.next = right\n                temp = temp.next\n                temp = temp.next\n                right = right.next\n                right = right.next\n        while left:\n        while left:\n            temp.next = left\n            temp.next = left\n            temp = temp.next\n            temp = temp.next\n            left = left.next\n            left = left.next\n        while right:\n        while right:\n            temp.next = right\n            temp.next = right\n            temp = temp.next\n            temp = temp.next\n            right = right.next\n            right = right.next\n        return dummy.next\n        return dummy.next\n    \n    def mergeSort(self, lists: List[ListNode], start: int, end: int) -> ListNode:\n    def mergeSort(self, lists: List[ListNode], start: int, end: int) -> ListNode:\n        if start == end:\n        if start == end:\n            return lists[start]\n            return lists[start]\n        mid = start + (end - start) // 2\n        mid = start + (end - start) // 2\n        left = self.mergeSort(lists, start, mid)\n        left = self.mergeSort(lists, start, mid)\n        right = self.mergeSort(lists, mid + 1, end)\n        right = self.mergeSort(lists, mid + 1, end)\n        return self.merge(left, right)\n        return self.merge(left, right)\n    \n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        if not lists:\n        if not lists:\n            return None\n            return None\n        return self.mergeSort(lists, 0, len(lists) - 1)\n        return self.mergeSort(lists, 0, len(lists) - 1)\n\n```"
    },
    "24. Swap Nodes in Pairs": {
        "problem": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n",
        "explanation": "Approach:\nThe approach used in the code is to traverse the linked list and swap adjacent pairs of nodes. This is done iteratively by maintaining a current pointer that points to the previous node before the pair to be swapped. The swapping is done by modifying the next pointers of the nodes.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        if not head or not head.next: return head\n        if not head or not head.next: return head\n\n        dummy = ListNode(0)\n        dummy = ListNode(0)\n        dummy.next = head\n        dummy.next = head\n        curr = dummy\n        curr = dummy\n\n        while curr.next and curr.next.next:\n        while curr.next and curr.next.next:\n            first = curr.next\n            first = curr.next\n            second = curr.next.next\n            second = curr.next.next\n            curr.next = second\n            curr.next = second\n            first.next = second.next\n            first.next = second.next\n            second.next = first\n            second.next = first\n            curr = curr.next.next\n            curr = curr.next.next\n        \n        return dummy.next        return dummy.next\n```"
    },
    "26. Remove Duplicates from Sorted Array": {
        "problem": "Given an integer array `nums` sorted in non\\-decreasing order, remove the duplicates in\\-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in `nums`.\n",
        "explanation": "Explanation:\nThe code starts iterating from `i = 1` because we need to compare each element with its previous element to check for duplicates.\n\n\nThe main logic is inside the `for` loop:\n\n\n1. If the current element `nums[i]` is not equal to the previous element `nums[i - 1]`, it means we have encountered a new unique element.\n2. In that case, we update `nums[j]` with the value of the unique element at `nums[i]`, and then increment `j` by 1 to mark the next position for a new unique element.\n3. By doing this, we effectively overwrite any duplicates in the array and only keep the unique elements.\n\n\nOnce the loop finishes, the value of `j` represents the length of the resulting array with duplicates removed.\n\n\nFinally, we return `j` as the desired result.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        j = 1\n        j = 1\n        for i in range(1, len(nums)):\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                nums[j] = nums[i]\n                j += 1\n                j += 1\n        return j        return j\n```"
    },
    "27. Remove Element": {
        "problem": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in\\-place. The order of the elements may be changed. Then return the number of elements in `nums` which are not equal to `val`.\n",
        "explanation": "Approach\n1. Initialize `index` to 0, which represents the current position for the next non\\-target element.\n2. Iterate through each element of the input array using the `i` pointer.\n3. For each element `nums[i]`, check if it is equal to the target value.\n\t* If `nums[i]` is not equal to `val`, it means it is a non\\-target element.\n\t* Set `nums[index]` to `nums[i]` to store the non\\-target element at the current `index` position.\n\t* Increment `index` by 1 to move to the next position for the next non\\-target element.\n4. Continue this process until all elements in the array have been processed.\n5. Finally, return the value of `index`, which represents the length of the modified array.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        index = 0\n        index = 0\n        for i in range(len(nums)):\n        for i in range(len(nums)):\n            if nums[i] != val:\n            if nums[i] != val:\n                nums[index] = nums[i]\n                nums[index] = nums[i]\n                index += 1\n                index += 1\n        return index        return index\n```"
    },
    "28. Find the Index of the First Occurrence in a String": {
        "problem": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.\n",
        "explanation": "Approach\n1. Use a loop to iterate through the `haystack` string. The loop starts at index `i = 0` and goes up to `i = haystack.length() - needle.length()`. This is done to ensure that there are enough characters left in the `haystack` for the needle to fit.\n2. Within the loop, check substrings of length equal to the length of the `needle` starting from the current index `i` up to `i + needle.length()`. If any of these substrings matches the `needle`, return the current index `i`.\n3. If the loop completes without finding a match, return \\-1\\.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def strStr(self, haystack, needle):\n    def strStr(self, haystack, needle):\n        for i in range(len(haystack) - len(needle) + 1):\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n            if haystack[i:i+len(needle)] == needle:\n                return i\n                return i\n        return -1        return -1\n```"
    },
    "29. Divide Two Integers": {
        "problem": "Given two integers `dividend` and `divisor`, divide two integers without using multiplication, division, and mod operator.\n",
        "explanation": "Approach\n* Handle division by zero: If the divisor is 0, return `2**31 - 1`.\n* Handle overflow case: If the dividend is `-2**31` and divisor is `-1`, return `2**31 - 1`.\n* Get the sign of the result: If both dividend and divisor are negative or positive, the sign of the result will be positive. If either dividend or divisor is negative, the sign of the result will be negative.\n* Find the largest multiple of the divisor that is less than or equal to the dividend using bit manipulation. We can do this by left\\-shifting the divisor and multiple by 1 until the left\\-shifted divisor is greater than the dividend.\n* Perform division using binary search. We can do this by right\\-shifting the divisor and multiple by 1 until multiple is 0\\. If the dividend is greater than or equal to the divisor, subtract the divisor from the dividend and add the multiple to the quotient. Repeat until multiple is 0\\.\n* Apply the sign to the quotient and return it.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Handle division by zero\n        # Handle division by zero\n        if divisor == 0:\n        if divisor == 0:\n            return 2**31 - 1\n            return 2**31 - 1\n        \n        # Handle overflow case\n        # Handle overflow case\n        if dividend == -2**31 and divisor == -1:\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n            return 2**31 - 1\n        \n        # Get the sign of the result\n        # Get the sign of the result\n        sign = 1\n        sign = 1\n        if dividend < 0:\n        if dividend < 0:\n            dividend = -dividend\n            dividend = -dividend\n            sign = -sign\n            sign = -sign\n        if divisor < 0:\n        if divisor < 0:\n            divisor = -divisor\n            divisor = -divisor\n            sign = -sign\n            sign = -sign\n        \n        # Find the largest multiple of the divisor that is less than or equal to the dividend\n        # Find the largest multiple of the divisor that is less than or equal to the dividend\n        multiple = 1\n        multiple = 1\n        while dividend >= (divisor << 1):\n        while dividend >= (divisor << 1):\n            divisor <<= 1\n            divisor <<= 1\n            multiple <<= 1\n            multiple <<= 1\n        \n        # Perform division using binary search\n        # Perform division using binary search\n        quotient = 0\n        quotient = 0\n        while multiple > 0:\n        while multiple > 0:\n            if dividend >= divisor:\n            if dividend >= divisor:\n                dividend -= divisor\n                dividend -= divisor\n                quotient += multiple\n                quotient += multiple\n            divisor >>= 1\n            divisor >>= 1\n            multiple >>= 1\n            multiple >>= 1\n        \n        # Apply the sign to the result\n        # Apply the sign to the result\n        return sign * quotient\n        return sign * quotient\n\n```"
    },
    "30. Substring with Concatenation of All Words": {
        "problem": "You are given a string `s` and an array of strings `words`. All the strings of `words` are of the same length.\n",
        "explanation": "Approach\n Sliding window \\+ hashtable for each word in words list and then inside nested loop use substrcount each time new and compare for equivalence\\\\.\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wordcount={}\n        wordcount={}\n        for word in words:\n        for word in words:\n            wordcount[word]=1+wordcount.get(word,0)\n            wordcount[word]=1+wordcount.get(word,0)\n        result=[]\n        result=[]\n        substringlength=len(words)*len(words[0])\n        substringlength=len(words)*len(words[0])\n        for i in range(len(s)-substringlength+1):\n        for i in range(len(s)-substringlength+1):\n            substr=s[i:i+substringlength]\n            substr=s[i:i+substringlength]\n            substrcount={}\n            substrcount={}\n            for j in range(0,len(substr),len(words[0])):\n            for j in range(0,len(substr),len(words[0])):\n                word=substr[j:j+len(words[0])]\n                word=substr[j:j+len(words[0])]\n                substrcount[word]=1+substrcount.get(word,0)\n                substrcount[word]=1+substrcount.get(word,0)\n            if substrcount==wordcount:\n            if substrcount==wordcount:\n                result.append(i)\n                result.append(i)\n        return result\n        return result\n\n\n#         m=''.join(words)\n#         m=''.join(words)\n\n#         pcount=dict()\n#         pcount=dict()\n\n#         scount=dict()\n#         scount=dict()\n\n#         if len(m)>len(s):\n#         if len(m)>len(s):\n\n#             print([])\n#             print([])\n\n#         for i in range(len(m)):\n#         for i in range(len(m)):\n\n#                  pcount[m[i]]=1+pcount.get(m[i],0)\n#                  pcount[m[i]]=1+pcount.get(m[i],0)\n\n#                  scount[s[i]]=1+scount.get(s[i],0)\n#                  scount[s[i]]=1+scount.get(s[i],0)\n\n# # print(pcount)\n# # print(pcount)\n\n# # print(scount)\n# # print(scount)\n\n#         res=[0]if pcount==scount else []\n#         res=[0]if pcount==scount else []\n\n#         l=0\n#         l=0\n\n#         for i in range(len(m),len(s),1):\n#         for i in range(len(m),len(s),1):\n\n#               scount[s[i]]=1+scount.get(s[i],0)\n#               scount[s[i]]=1+scount.get(s[i],0)\n\n#               scount[s[l]]-=1 \n#               scount[s[l]]-=1 \n\n#               if scount[s[l]]==0:\n#               if scount[s[l]]==0:\n\n#                   del scount[s[l]]\n#                   del scount[s[l]]\n\n#               l+=1 \n#               l+=1 \n\n#               if scount==pcount:\n#               if scount==pcount:\n\n#                 res.append(l)\n#                 res.append(l)\n\n# #@print(res)\n# #@print(res)\n\n#         return res\n#         return res\n        \n```"
    },
    "31. Next Permutation": {
        "problem": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n",
        "explanation": "Algorithm\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.  \n\nFor example, no next permutation is possible for the following array:\n\n\n\n```\n[9, 5, 4, 3, 1]\n```\n\nWe need to find the first pair of two successive numbers a\\[i] and a\\[iâˆ’1], from the right, which satisfy  \n\na\\[i]\\>a\\[iâˆ’1]. Now, no rearrangements to the right of a\\[iâˆ’1] can create a larger permutation since that subarray consists of numbers in descending order.  \n\nThus, we need to rearrange the numbers to the right of a\\[iâˆ’1] including itself.\n\n\nNow, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number a\\[iâˆ’1] with the number which is just larger than itself among the numbers lying to its right section, say a\\[j].\n\n\n![ Next Permutation ](https://leetcode.com/media/original_images/31_nums_graph.png)\n\n\nWe swap the numbers a\\[iâˆ’1] and a\\[j]. We now have the correct number at index iâˆ’1. But still the current permutation isn't the permutation  \n\nthat we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of a\\[iâˆ’1]. Therefore, we need to place those  \n\nnumbers in ascending order to get their smallest permutation.\n\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index  \n\nuntil we found the pair a\\[i] and a\\[iâˆ’1] where, a\\[i]\\>a\\[iâˆ’1]. Thus, all numbers to the right of a\\[iâˆ’1] were already sorted in descending order.  \n\nFurthermore, swapping a\\[iâˆ’1] and a\\[j] didn't change that order.  \n\nTherefore, we simply need to reverse the numbers following a\\[iâˆ’1] to get the next smallest lexicographic permutation.\n\n\nThe following animation will make things clearer:\n\n\n![Next Permutation](https://leetcode.com/media/original_images/31_Next_Permutation.gif)\n\n\n\n**Complexity Analysis**\n\n\n* Time complexity : O(n). In worst case, only two scans of the whole array are needed.\n* Space complexity : O(1). No extra space is used. In place replacements are done.\n\n\\</ul",
        "solution": "```python\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i + 1] <= nums[i]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            self.swap(nums, i, j)\n        self.reverse(nums, i + 1)\n\n    def reverse(self, nums, start):\n        i, j = start, len(nums) - 1\n        while i < j:\n            self.swap(nums, i, j)\n            i += 1\n            j -= 1\n\n    def swap(self, nums, i, j):\n        temp = nums[i]\n        nums[i] = nums[j]\n        nums[j] = temp\n```"
    },
    "32. Longest Valid Parentheses": {
        "problem": "Given a string containing just the characters `'('` and `')'`, return the length of the longest valid (well\\-formed) parentheses substring.\n",
        "explanation": "Approach\n1. Initialize an array arr of length n, where n is the length of the input string s, filled with zeros.\n2. Initialize an empty stack.\n3. Iterate through each character s\\[i] in the input string s.\n4. If s\\[i] is '(', push its index i onto the stack.\n5. If s\\[i] is ')' and the stack is not empty, mark the corresponding opening parenthesis index and the current index as valid by setting arr\\[stack.pop()] \\= 1 and arr\\[i] \\= 1\\.\n6. Now we need to find longest consecutive 1s in the array :)\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n    def longestValidParentheses(self, s: str) -> int:\n        n = len(s)\n        n = len(s)\n        arr = [0]*n\n        arr = [0]*n\n        stack = []\n        stack = []\n\n        for i in range(n):\n        for i in range(n):\n            if s[i]=='(':\n            if s[i]=='(':\n                stack.append(i)\n                stack.append(i)\n            if s[i]==')' and stack:\n            if s[i]==')' and stack:\n                arr[stack.pop()]=1\n                arr[stack.pop()]=1\n                arr[i]=1\n                arr[i]=1\n        \n        ans = 0\n        ans = 0\n        temp = 0\n        temp = 0\n        for i in arr:\n        for i in arr:\n            if i==1:\n            if i==1:\n                temp+=1\n                temp+=1\n                ans = max(ans,temp)\n                ans = max(ans,temp)\n            else:\n            else:\n                temp=0\n                temp=0\n\n        return ans\n        return ans\n        \n```"
    },
    "33. Search in Rotated Sorted Array": {
        "problem": "There is an integer array `nums` sorted in ascending order (with distinct values).\n",
        "explanation": "Approach\nGiven the properties of the array, it's tempting to perform a linear search. However, that would result in a time complexity of O(n). Instead, we can use the properties of the array to our advantage and apply a binary search to find the target with time complexity of O(logn) only.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n        while left <= right:\n            mid = (left + right) // 2\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n            if nums[mid] == target:\n                return mid\n                return mid\n\n            # Check if left half is sorted\n            # Check if left half is sorted\n            if nums[left] <= nums[mid]:\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                    right = mid - 1\n                else:\n                else:\n                    left = mid + 1\n                    left = mid + 1\n            # Otherwise, right half is sorted\n            # Otherwise, right half is sorted\n            else:\n            else:\n                if nums[mid] < target <= nums[right]:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                    left = mid + 1\n                else:\n                else:\n                    right = mid - 1\n                    right = mid - 1\n\n        return -1        return -1\n```"
    },
    "34. Find First and Last Position of Element in Sorted Array": {
        "problem": "Given an array of integers `nums` sorted in non\\-decreasing order, find the starting and ending position of a given `target` value.\n",
        "explanation": "Approach\nThe idea is that we have to return two indices, one for start of the target and one for end of the target in an array. So, we use two different functions, one would go and try to find the starting index, the other to find the end index. as simple as that! We have two helper functions in the code below which are responsible for these tasks. The main function is just a wrapper that initializa (line #1) the output and assign updated values (line #2, 3) from helper functions and return results (line #4) at the end.",
        "solution": "```python\nclass Solution(object): \n\n#### Main function\n\n    def searchRange(self, nums, target):\n        \n        result = [-1, -1] #1\n        \n        result[0] = self.findStartingIndex(nums, target)  #2 \n        result[1] = self.findEndingIndex(nums, target)  #3\n        \n        return result #4\n         \n#### Helper function 1 \n\n    def findStartingIndex(self, nums, target):\n        index = -1 #5 \n        low, high = 0, len(nums) -1 #6\n        \n        while low <= high: #7\n            mid = low + (high - low)/2 #8\n                    \n            if nums[mid] == target: #9\n                index = mid #10\n                high = mid - 1 #11\n            elif nums[mid] > target:  #12\n                high = mid - 1 #13\n            else:  #14\n                low = mid + 1 #15       \n        \n        return index\n        \n#### Helper function 2\n  \n    def findEndingIndex(self, nums, target):\n        index = -1\n        low, high = 0, len(nums) -1\n        \n        while low <= high:\n            \n            mid = low + (high - low)/2\n            \n            if nums[mid] == target:\n                index = mid\n                low = mid + 1 #16\n            elif nums[mid] > target: \n                high = mid - 1\n            else:\n                 low = mid + 1\n            \n            \n        \n        return index\n```"
    },
    "35. Search Insert Position": {
        "problem": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n",
        "explanation": "Approach\nThe description says \"Given a sorted array of distinct integers and ...\" and \"You must write an algorithm with O(logn) runtime complexity\".\n\n\nSo we should solve this question with `binary search`.\n\n\nThere are two cases that we should focus on. One is we have the target in the array and the other is we don't have the target in the array.\n\n\n\n```\nInput: nums = [1,3,5,6], target = 5\n```\n\nFirst of all, let's see we have the target in the array. Actually this is just typical binary search.\n\n\n\n\n---\n\n\nâ­ï¸ Points\n\n\n\n```\nmiddle pointer = (left index + right index) // 2\n```\n\n\n\n---\n\n\n\n```\n[1,3,5,6]\n L M   R  \n```\n\nNow middle number(\\= `M`) is less than the `target`(\\= 5\\), so move left pointer(\\= `L`) to `M + 1`.\n\n\n\n```\n[1,3,5,6]\n     L R\n     M\n```\n\nNow middle pointer is at index `2`. middle number is equal to the target.\n\n\n\n```\nreturn 2 (= middle index)\n```\n\nThat is typical case.\n\n\n\n\n---\n\n\nLet's look at the case where the target number is not present.\n\n\n\n```\nInput: nums = [1,3,5,6], target = 2\n```\n\n\n```\n[1,3,5,6]\n L M   R\n```\n\nNow middle number is greater than the target, so move `R` to `M - 1`.\n\n\n\n```\n[1,3,5,6]\n L\n R\n M\n```\n\nNow middle number is less than the target, so move `L` to `M + 1`.\n\n\n\n```\n[1,3,5,6]\n R L\n```\n\nNow `L` is greater than `R`. We stop binary search. As a result, we don't find the target.\n\n\nThe description says \"return the index where it would be if it were inserted in order.\"\n\n\nIn this case, we should insert the target into index `1`. As you see, `L` is now at index `1`, so\n\n\n\n```\nreturn 1 (= left index)\n```\n\n\n\n---\n\n\nâ­ï¸ Points\n\n\nReturn left index if you don't find the target.\n\n\n\n\n---\n\n\nEasy!ðŸ˜„  \n\nLet's see solution codes and step by step algorithm!\n\n\n\n\n---\n\n\n\n\n\n---\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        left = 0\n        right = len(nums) - 1\n        right = len(nums) - 1\n\n        while left <= right:\n        while left <= right:\n            mid = (left + right) // 2\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n            if nums[mid] == target:\n                return mid\n                return mid\n            elif nums[mid] > target:\n            elif nums[mid] > target:\n                right = mid - 1\n                right = mid - 1\n            else:\n            else:\n                left = mid + 1\n                left = mid + 1\n        \n        return left        return left\n```"
    },
    "36. Valid Sudoku": {
        "problem": "Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n",
        "explanation": "Approach\nWe can't have duplicate numbers at each row, column and box(3 \\* 3\\), so it's good idea to have data of each row, column and box whether we check current number is duplicate.\n\n\nFor example,\n\n\n\n```\nrows[0] - 5,7,8,9\n    [1] - 1,2\n    [2] - 4,8\n    .\n    .\n    .\n\ncols[0] - 1,2\n    [1] - 3,4\n    .\n    .\n    .\n```\n\nThat means\n\n\n\n```\n- We have `5,7,8,9` at row `0`.\n- We have `1`,`2` at row `1`.\n- We have `4`,`8` at row `2`.\n- We have `1`,`2` at column `0`.\n- We have `3`,`4` at column `1`. \n```\n\nLet's say we have row 0 like this.\n\n\n\n```\n      0 1 2 3 4 5 6 7 8 (column number)\nrow0: 5,6,8,9,x,x,x,x,9\nrow1: x,x,x,x,x,x,x,x,x,\n```\n\nAt board\\[0]\\[0], we have `5`  \n\nAt board\\[0]\\[1], we have `6`  \n\nAt board\\[0]\\[2], we have `8`  \n\nAt board\\[0]\\[3], we have `9`\n\n\nNow we have\n\n\n\n```\nrows[0] - 5,7,8,9\n```\n\nLook at the `board[0][8]`. We have `9` at row `0`. That `9` is duplicate because we already have `9` at row `0`, so we should return `False`.\n\n\nWe apply the same idea to column direction and box. But let me explain box position.\n\n\nWe should have the same data for box whether we check current number is duplicate or not. But problem is size of one box is `3 * 3`, so we can't keep data like rows and columns. We are not allowed to have the same number in box which is size of `3 * 3`.\n\n\nHow do you deal with the problem?\n\n\nMy strategy is to use tuple as a key. For example, left top box should be from index `0` to index `2` of rows and columns.\n\n\nWe know that size of one box is `3 * 3`, so if we divide index number by `3`, we can point to the target box.\n\n\nFor example, if we are now at board\\[2]\\[1] and find `7`, box should be\n\n\n\n```\n2 // 3 = 0\n1 // 3 = 0\n```\n\nso, the target box should be\n\n\n\n```\nboxes[(0, 0)] - 7\n```\n\nif we are now at board\\[8]\\[6] and find `5`,\n\n\n\n```\n8 // 3 = 2\n6 // 3 = 2\n```\n\nso, the target box should be\n\n\n\n```\nboxes[(2, 2)] - 5\n```\n\nWe have nine 3 \\* 3 boxes.\n\n\n\n```\n     012  345  678 â†’ column number\n012 (0,0)(0,1)(0,2)\n345 (1,0)(1,1)(1,2)\n678 (2,0)(2,1)(2,2)\nâ†“\nrow number\n\neach box is 3 * 3\nWe are not allowed to have duplicate number in each box.\n```\n\nEasy!ðŸ˜„  \n\nLet's see real algorithm!\n\n\n\n\n---\n\n\n\n\n\n---\n\n\n`code`\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = defaultdict(set)\n        rows = defaultdict(set)\n        cols = defaultdict(set)\n        cols = defaultdict(set)\n        boxes = defaultdict(set)\n        boxes = defaultdict(set)\n        \n        for r in range(9):\n        for r in range(9):\n            for c in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                if board[r][c] == \".\":\n                    continue\n                    continue\n                \n                if board[r][c] in rows[r] or board[r][c] in cols[c] or board[r][c] in boxes[(r // 3, c // 3)]:\n                if board[r][c] in rows[r] or board[r][c] in cols[c] or board[r][c] in boxes[(r // 3, c // 3)]:\n                    return False\n                    return False\n                \n                rows[r].add(board[r][c])\n                rows[r].add(board[r][c])\n                cols[c].add(board[r][c])\n                cols[c].add(board[r][c])\n                boxes[(r // 3, c // 3)].add(board[r][c])\n                boxes[(r // 3, c // 3)].add(board[r][c])\n        \n        return True        return True\n```"
    },
    "37. Sudoku Solver": {
        "problem": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n",
        "explanation": "Approach\n",
        "solution": "```python\nfrom typing import List\nfrom typing import List\n\nclass Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        \"\"\"\n        Solves the Sudoku puzzle in-place.\n\n        Parameters:\n            board (List[List[str]]): 9x9 Sudoku board represented as a list of lists.\n        \"\"\"\n        \"\"\"\n        n = 9\n        n = 9\n\n        def isValid(row, col, num):\n        def isValid(row, col, num):\n            for i in range(n):\n            for i in range(n):\n                if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n                    return False\n            return True\n            return True\n\n        def solve(row, col):\n        def solve(row, col):\n            if row == n:\n            if row == n:\n                return True\n                return True\n            if col == n:\n            if col == n:\n                return solve(row + 1, 0)\n                return solve(row + 1, 0)\n\n            if board[row][col] == \".\":\n            if board[row][col] == \".\":\n                for num in map(str, range(1, 10)):\n                for num in map(str, range(1, 10)):\n                    if isValid(row, col, num):\n                    if isValid(row, col, num):\n                        board[row][col] = num\n                        board[row][col] = num\n                        if solve(row, col + 1):\n                        if solve(row, col + 1):\n                            return True\n                            return True\n                        else:\n                        else:\n                            board[row][col] = \".\"\n                            board[row][col] = \".\"\n                return False\n                return False\n            else:\n            else:\n                return solve(row, col + 1)\n                return solve(row, col + 1)\n\n        solve(0, 0)\n        solve(0, 0)\n\n##Upvote me If it helps please\n##Upvote me If it helps please\n\n```"
    },
    "39. Combination Sum": {
        "problem": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.\n",
        "explanation": "Approach \\#1\\. DFS (Backtracking)\n* Straight forward backtracking\n* `cur`: current combination, `cur_sum` current combination sum, `idx` index current at (to avoid repeats)\n* Time complexity: `O(N^(M/min_cand + 1))`, `N = len(candidates)`, `M = target`, `min_cand = min(candidates)`\n* Space complexity: `O(M/min_cand)`\n\n\n\n",
        "solution": "```python\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        ans = []\n        n = len(candidates)\n        def dfs(cur, cur_sum, idx):                       # try out each possible cases\n            if cur_sum > target: return                   # this is the case, cur_sum will never equal to target\n            if cur_sum == target: ans.append(cur); return # if equal, add to `ans`\n            for i in range(idx, n): dfs(cur + [candidates[i]], cur_sum + candidates[i], i) # DFS\n        dfs([], 0, 0)\n        return ans\n```"
    },
    "40. Combination Sum II": {
        "problem": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n",
        "explanation": "Approach\nThis code is an algorithm to find all combinations from the given `candidates` list that sum up to `target`. First, the `candidates` list is sorted in non\\-decreasing order. An empty list `res` is initialized to store all valid combinations. The recursive function `dfs` takes parameters `target` (current total sum), `start` (starting index in candidates), and `comb` (current combination being built). As base cases, if `target < 0`, the function returns immediately, and if `target == 0`, `comb` is added to `res`. The `dfs` function iterates through the `candidates` list from `start`, skipping duplicates and ensuring no reuse of values to avoid redundancy. It also terminates search paths if the current candidate exceeds `target`. The initial call `dfs(target, 0, [])` starts the exploration, and after all valid combinations are found, `res` is returned.\n\n\n\n\n---\n\n\nâ­ï¸ I recently created a video on how I've been using LeetCode to learn.\n\n\n\n\n\n---\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        candidates.sort()\n        res = []\n        res = []\n\n        def dfs(target, start, comb):\n        def dfs(target, start, comb):\n            if target < 0:\n            if target < 0:\n                return\n                return\n            if target == 0:\n            if target == 0:\n                res.append(comb)\n                res.append(comb)\n                return\n                return\n            for i in range(start, len(candidates)):\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                    continue\n                if candidates[i] > target:\n                if candidates[i] > target:\n                    break\n                    break\n                dfs(target-candidates[i], i+1, comb+[candidates[i]])\n                dfs(target-candidates[i], i+1, comb+[candidates[i]])\n\n        dfs(target, 0, [])\n        dfs(target, 0, [])\n        return res\n        return res\n\n```"
    },
    "41. First Missing Positive": {
        "problem": "Given an unsorted integer array `nums`. Return the smallest positive integer that is not present in `nums`.\n",
        "explanation": "Algorithm\n1. Initialize a variable `n` to the length of `nums`.\n2. Use cycle sort to place positive elements smaller than `n` at the correct index.\n\n\n\t* Initialize a variable `i` to `0`.\n\t* Iterate through the elements in `nums`:\n\t\t+ Set a variable `correctIdx` to `nums[i] - 1`.\n\t\t+ If the `nums[i]` is greater than zero, less than or equal to `n`, and does not equal `nums[correctIdx]`, swap the element at `nums[i]` with the element at `nums[correctIdx]`.\n\t\t+ Otherwise, increment `i`.\n3. Iterate through sorted `nums` and return the smallest missing positive number.\n\n\n\t* For each element in `nums`, if `nums[i]` does not equal `i + 1`, return `i + 1`, the smallest missing positive number.\n4. Return `n + 1`, the smallest missing positive number when each number in `nums` is in the correct position.\n\n\n\n#### \n\n",
        "solution": "```python\nclass Solution:\n    def firstMissingPositive(self, nums):\n        n = len(nums)\n        seen = [False] * (n + 1)  # Array for lookup\n\n        # Mark the elements from nums in the lookup array\n        for num in nums:\n            if 0 < num <= n:\n                seen[num] = True\n\n        # Iterate through integers 1 to n\n        # return smallest missing positive integer\n        for i in range(1, n + 1):\n            if not seen[i]:\n                return i\n\n        # If seen contains all elements 1 to n\n        # the smallest missing positive number is n + 1\n        return n + 1\n```"
    },
    "42. Trapping Rain Water": {
        "problem": "Given `n` non\\-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n",
        "explanation": "Approach\nTo keep water, we have to have a bar on the left side and on the right side. Between them, we can keep water.\n\n\nLet's think about this example.\n\n\n\n```\nInput: height = [2,1,0,1,3,2]\n```\n\n![ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ 2024-05-08 1.03.27.png](https://assets.leetcode.com/users/images/5a1d20ee-1685-4eb5-98a9-b34596762c26_1715097837.7286208.png)\n\n\nI think we can easily imagine that we can keep water at `0 height`(\\= index `2`), because we have bars in the adjacent places(\\= index `1` and `3`).\n\n\nBut how about `1 height` at index `1`. We can keep water there. I think left side is easy to imagine because we have a bar in adjacent place(\\= index `0`). But how about right side? In the end, we can keep water because we have `3 height` at index `4`.\n\n\n\n\n---\n\n\nQuestion\n\n\nHow can we judge if we can have water when there is some distance between water and a bar? In this case, water is at index `1` and the bar is at index `4`.\n\n\n\n\n---\n\n\nMy strategy is to keep `max height of left and right`. I'll show you how algorithm works.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n    def trap(self, height: List[int]) -> int:\n        left = 0\n        left = 0\n        right = len(height) - 1\n        right = len(height) - 1\n        left_max = height[left]\n        left_max = height[left]\n        right_max = height[right]\n        right_max = height[right]\n        water = 0\n        water = 0\n\n        while left < right:\n        while left < right:\n            if left_max < right_max:\n            if left_max < right_max:\n                left += 1\n                left += 1\n                left_max = max(left_max, height[left])\n                left_max = max(left_max, height[left])\n                water += left_max - height[left]\n                water += left_max - height[left]\n            else:\n            else:\n                right -= 1\n                right -= 1\n                right_max = max(right_max, height[right])\n                right_max = max(right_max, height[right])\n                water += right_max - height[right]\n                water += right_max - height[right]\n        \n        return water        return water\n```"
    },
    "43. Multiply Strings": {
        "problem": "Given two non\\-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n",
        "explanation": "Algorithm\n1. Reverse both numbers.\n2. Initialize `answer` with N\\+M zeros.\n3. For each digit at position `i` in `secondNumber`:\n\t* For each digit at position `j` in `firstNumber`:\n\t\t+ Multiply the digit from `secondNumber` by the digit from `firstNumber` and add previously carried value to the `multiplication` result. The previously carried value can be found at position `i + j` in the `answer`.\n\t\t+ Take the remainder of `multiplication` with `10` to get the ones place digit of the `multiplication` result.\n\t\t+ Put the last digit at current position (position `i + j`) in `answer`.\n\t\t+ Divide the `multiplication` by `10` to get the new value for carry and add it to `answer` at the next position. Note, the next position is located at `(i + j + 1)`.\n4. If the last digit in `answer` is zero, before reversing `answer`, we must pop the zero from `answer`. Otherwise, there would be a leading zero in the final answer.\n5. Reverse `answer` and return it.\n\n\n\n#### \n\n",
        "solution": "```python\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        # Reverse both numbers.\n        first_number = num1[::-1]\n        second_number = num2[::-1]\n\n        # For each digit in second_number, multipy the digit by first_number and then\n        # store the multiplication result (reversed) in the results array.\n        results = []\n        for index, digit in enumerate(second_number):\n            results.append(self.multiply_one_digit(digit, index, first_number))\n\n        # Add all of the results together to get our final answer (in reverse order)\n        answer = self.sum_results(results)\n\n        # Reverse answer and join the digits to get the final answer.\n        return \"\".join(str(digit) for digit in reversed(answer))\n\n    def multiply_one_digit(\n        self, digit2: str, num_zeros: int, first_number: List[str]\n    ) -> List[int]:\n        \"\"\"Multiplies first_number by a digit from second_number (digit2).\"\"\"\n        # Insert zeros at the beginning of the current result based on the current digit's place.\n        current_result = [0] * num_zeros\n        carry = 0\n\n        # Multiply each digit in first_number with the current digit of the second_number.\n        for digit1 in first_number:\n            multiplication = int(digit1) * int(digit2) + carry\n            # Set carry equal to the tens place digit of multiplication.\n            carry = multiplication // 10\n            # Append last digit to the current result.\n            current_result.append(multiplication % 10)\n\n\n            current_result.append(carry)\n        return current_result\n\n    def sum_results(self, results: List[List[int]]) -> List[int]:\n        # Initialize answer as a number from results.\n        answer = results.pop()\n\n```"
    },
    "45. Jump Game II": {
        "problem": "You are given a 0\\-indexed array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n",
        "explanation": "Explanation to Approach :\n* We are using a search algorithm that works by moving forward in steps and counting each step as a jump.\n* The algorithm keeps track of the farthest reachable position at each step and updates the number of jumps needed to reach that farthest position.\n* The algorithm returns the minimum number of jumps needed to reach the end of the array.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n  def jump(self, nums: List[int]) -> int:\n  def jump(self, nums: List[int]) -> int:\n    ans = 0\n    ans = 0\n    end = 0\n    end = 0\n    farthest = 0\n    farthest = 0\n\n    # Implicit BFS\n    # Implicit BFS\n    for i in range(len(nums) - 1):\n    for i in range(len(nums) - 1):\n      farthest = max(farthest, i + nums[i])\n      farthest = max(farthest, i + nums[i])\n      if farthest >= len(nums) - 1:\n      if farthest >= len(nums) - 1:\n        ans += 1\n        ans += 1\n        break\n        break\n      if i == end:      # Visited all the items on the current level\n      if i == end:      # Visited all the items on the current level\n        ans += 1        # Increment the level\n        ans += 1        # Increment the level\n        end = farthest  # Make the queue size for the next level\n        end = farthest  # Make the queue size for the next level\n\n    return ans    return ans\n```"
    },
    "46. Permutations": {
        "problem": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.\n",
        "explanation": "Approach\nThis is based on Python solution. Other might be different a bit.\n\n\n1. The function `permute` takes a list of integers `nums` as input and aims to generate all possible permutations of the elements in the input list.\n2. The base case is checked: if the length of the `nums` list is 1, then it means there's only one element left to permute, and at this point, a list containing that single element is returned as a permutation.\n3. If the `nums` list has more than one element, the algorithm proceeds with permutation generation.\n4. Initialize an empty list `res` to store the permutations.\n5. Iterate over each element in the `nums` list (using `_` as a placeholder for the loop variable). In each iteration, pop the first element `n` from the `nums` list.\n6. Recursively call the `permute` function on the remaining elements in `nums` after removing the first element. This generates all possible permutations of the remaining elements.\n7. For each permutation `p` generated in the recursive call, append the previously removed element `n` to it.\n8. Extend the `res` list with the permutations generated in the recursive calls, each with the element `n` appended.\n9. After the loop completes, add the removed element `n` back to the end of the `nums` list, restoring the original state for the next iteration.\n10. Finally, return the list `res` containing all the generated permutations.\n\n\nIn summary, this code uses a recursive approach to generate all possible permutations of the input list `nums`. It removes one element at a time, generates permutations for the remaining elements, appends the removed element to those permutations, and collects all permutations in the `res` list. The recursion continues until only one element is left in the list, at which point a permutation containing that single element is returned.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) == 1:\n        if len(nums) == 1:\n            return [nums[:]]\n            return [nums[:]]\n        \n        res = []\n        res = []\n\n        for _ in range(len(nums)):\n        for _ in range(len(nums)):\n            n = nums.pop(0)\n            n = nums.pop(0)\n            perms = self.permute(nums)\n            perms = self.permute(nums)\n\n            for p in perms:\n            for p in perms:\n                p.append(n)\n                p.append(n)\n            \n            res.extend(perms)\n            res.extend(perms)\n            nums.append(n)\n            nums.append(n)\n        \n        return res\n        return res\n            \n```"
    },
    "47. Permutations II": {
        "problem": "Given a collection of numbers, `nums`, that might contain duplicates, return all possible unique permutations in any order.\n",
        "explanation": "Algorithm\nGiven the above insight, in order to find out all the unique numbers at each stage, we can build a ***hash table*** (denoted as `counter`), with each unique number as the key and its occurrence as the corresponding value.\n\n\nTo implement the algorithm, first we define a function called `backtrack(comb, counter)` which generates all permutations, starting from the current combination (`comb`) and the remaining numbers (`counter`).\n\n\nOnce the function is implemented, it suffices to invoke the function with the initial empty combination and the hash table we built out of the input array, to solve the problem.\n\n\nHere are some sample implementations.\n\n\n\n**Note:** for a backtracking algorithm, usually there are some explorations that would lead to a *dead end*, and we have to abandon those explorations in the middle.\n\n\nHowever, due to the specificity of this problem and our exploration strategy, each exploration will result in a valid permutation, *i.e.* none of the efforts is in vain.  \n\nThis insight would prove to be useful in the following complexity analysis.\n\n\n**Complexity Analysis**\n\n\nLet N be the length of the input array.  \n\nHence, the number of permutations would be at maximum N!, *i.e.* Nâ‹…(Nâˆ’1)â‹…(Nâˆ’2)...1, when each number in the array is unique.\n\n\n* Time Complexity: O(âˆ‘k\\=1Nâ€‹P(N,k)) where P(N,k)\\=(Nâˆ’k)!N!â€‹\\=N(Nâˆ’1)...(Nâˆ’k\\+1)  \n\nis so\\-called [*k\\-permutations\\_of\\_N* or *partial permutation*](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n).\n\n\n\t+ As one can see in the exploration graph we have shown earlier, the execution of the backtracking algorithm will unfold itself as a tree, where each node is an invocation of the recursive function `backtrack(comb, counter)`.  \n\t\n\tThe total number of steps to complete the exploration is *exactly* the number of nodes in the tree.  \n\t\n\tTherefore, the time complexity of the algorithm is linked directly with the size of the tree.\n\t+ It now boils down to estimating the number of nodes in the tree.  \n\t\n\tAs we know now, each level of the tree corresponds to a specific *stage* of the exploration.  \n\t\n\tAt each stage, the number of candidates to explore is **bounded**.  \n\t\n\tFor instance, at the first stage, *at most* we would have N candidates to explore, *i.e.* the number of nodes at this level would be N.  \n\t\n\tMoving on to the next stage, for each of the nodes in the first stage, we would have Nâˆ’1 child nodes. Therefore, the number of nodes at this stage would be Nâ‹…(Nâˆ’1).  \n\t\n\tSo on and so forwards.![number of nodes](../Figures/47/47_number_of_nodes.png)\n\n\n\t+ By summing up all the nodes across the stages, we would then obtain the total number of nodes as âˆ‘k\\=1Nâ€‹P(N,k) where P(N,k)\\=(Nâˆ’k)!N!â€‹\\=N(Nâˆ’1)...(Nâˆ’k\\+1).  \n\t\n\tAs a result, the exact time complexity of the algorithm is O(âˆ‘k\\=1Nâ€‹P(N,k)).\n\t+ The above complexity might appear a bit too abstract to comprehend.  \n\t\n\tHere we could provide another ***loose upper bound*** on the complexity.\n\t+ It takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take us Nâ‹…N! steps to generate all permutations, simply assuming that there is no overlapping effort (which is not true).\n* Space Complexity: O(N)\n\n\n\t+ First of all, we build a hash table out of the input numbers. In the worst case where each number is unique, we would need O(N) space for the table.\n\t+ Since we applied recursion in the algorithm which consumes some extra space in the function call stack, we would need another O(N) space for the recursion.\n\t+ During the exploration, we keep a candidate of permutation along the way, which takes yet another O(N).\n\t+ To sum up, the total space complexity would be O(N)\\+O(N)\\+O(N)\\=O(N).\n\t+ **Note**, we did not take into account the space needed to hold the results. Otherwise, the space complexity would become O(Nâ‹…N!).\n\n\n\\<hr",
        "solution": "```python\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        results = []\n\n        def backtrack(comb, counter):\n            if len(comb) == len(nums):\n                # make a deep copy of the resulting permutation,\n                # since the permutation would be backtracked later.\n                results.append(list(comb))\n                return\n\n            for num in counter:\n                if counter[num] > 0:\n                    # add this number into the current combination\n                    comb.append(num)\n                    counter[num] -= 1\n                    # continue the exploration\n                    backtrack(comb, counter)\n                    # revert the choice for the next exploration\n                    comb.pop()\n                    counter[num] += 1\n\n        backtrack([], Counter(nums))\n\n        return results\n```"
    },
    "48. Rotate Image": {
        "problem": "You are given an `n x n` 2D `matrix` representing an image, rotate the image by 90 degrees (clockwise).\n",
        "explanation": "Approach\n1. **Transpose Step:**\n\t* The transpose method swaps the elements across the main diagonal of the matrix.\n\t* It iterates through the upper triangle of the matrix (matrix\\[i]\\[j] and matrix\\[j]\\[i]) and exchanges the values.\n2. **Reverse Rows Step:**\n\t* The reverseRows method then reverses each row of the transposed matrix.\n\t* For each row (matrix\\[r]), it uses two pointers (left and right) to swap elements symmetrically across the center.\n3. **Combination in rotate Method:**\n\t* The rotate method combines these two steps to achieve a 90\\-degree clockwise rotation.\n\t* It first transposes the matrix and then reverses the rows of the transposed matrix.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \"\"\"\n        def transpose(matrix):\n        def transpose(matrix):\n            for i in range(len(matrix)):\n            for i in range(len(matrix)):\n                for j in range(i, len(matrix[0])):\n                for j in range(i, len(matrix[0])):\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        def reverse_rows(matrix):\n        def reverse_rows(matrix):\n            for r in range(len(matrix)):\n            for r in range(len(matrix)):\n                left, right = 0, len(matrix) - 1\n                left, right = 0, len(matrix) - 1\n                while left < right:\n                while left < right:\n                    matrix[r][left], matrix[r][right] = matrix[r][right], matrix[r][left]\n                    matrix[r][left], matrix[r][right] = matrix[r][right], matrix[r][left]\n                    left += 1\n                    left += 1\n                    right -= 1\n                    right -= 1\n\n        transpose(matrix)\n        transpose(matrix)\n        reverse_rows(matrix)        reverse_rows(matrix)\n```"
    },
    "49. Group Anagrams": {
        "problem": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n",
        "explanation": "Explanation:\nLet's go through the code step by step using the example input `[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]` to understand how it works.\n\n\n1. **Initializing Variables**\n\n\n\t* We start by initializing an empty unordered map called `mp` (short for map), which will store the groups of anagrams.\n2. **Grouping Anagrams**  \n\nWe iterate through each word in the input vector `strs`. Let's take the first word, \"eat\", as an example.\n\n\n\t* **Sorting the Word**  \n\t\n\tWe create a string variable called `word` and assign it the value of the current word (\"eat\" in this case).\n\t\n\t\n\tNext, we sort the characters in `word` using the `sort()` function. After sorting, `word` becomes \"aet\".\n\t* **Grouping the Anagram**  \n\t\n\tWe insert `word` as the key into the `mp` unordered map using `mp[word]`, and we push the original word (\"eat\") into the vector associated with that key using `mp[word].push_back(x)`, where `x` is the current word.\n\t\n\t\n\tSince \"aet\" is a unique sorted representation of all the anagrams, it serves as the key in the `mp` map, and the associated vector holds all the anagrams.\n\n\nFor the given example, the `mp` map would look like this after processing all the words:\n\n\n\n```\n{\n  \"aet\": [\"eat\", \"tea\", \"ate\"],\n  \"ant\": [\"tan\", \"nat\"],\n  \"abt\": [\"bat\"]\n}\n```\n\n3. **Creating the Result**  \n\nWe initialize an empty vector called `ans` (short for answer) to store the final result.\n\n\n\t* We iterate through each key\\-value pair in the `mp` map using a range\\-based for loop. For each pair, we push the vector of anagrams (`x.second`) into the `ans` vector.\n\n\nFor the given example, the `ans` vector would look like this:\n\n\n\n```\n[\n  [\"eat\", \"tea\", \"ate\"],\n  [\"tan\", \"nat\"],\n  [\"bat\"]\n]\n```\n\n4. **Returning the Result**  \n\nWe return the `ans` vector, which contains the groups of anagrams.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def groupAnagrams(self, strs):\n    def groupAnagrams(self, strs):\n        anagram_map = defaultdict(list)\n        anagram_map = defaultdict(list)\n        \n        for word in strs:\n        for word in strs:\n            sorted_word = ''.join(sorted(word))\n            sorted_word = ''.join(sorted(word))\n            anagram_map[sorted_word].append(word)\n            anagram_map[sorted_word].append(word)\n        \n        return list(anagram_map.values())        return list(anagram_map.values())\n```"
    },
    "52. N-Queens II": {
        "problem": "The n\\-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n",
        "explanation": "",
        "solution": ""
    },
    "53. Maximum Subarray": {
        "problem": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.\n",
        "explanation": "Approach:\n1. We start by initializing two variables: `maxSum` and `currentSum`.\n\t* `maxSum` represents the maximum sum encountered so far and is initially set to the minimum possible integer value to ensure that any valid subarray sum will be greater than it.\n\t* `currentSum` represents the current sum of the subarray being considered and is initially set to 0\\.\n2. We iterate through the `nums` array using a for loop, starting from the first element and going up to the last element.\n3. For each element in the array, we add it to the current sum `currentSum`. This calculates the sum of the subarray ending at the current element.\n4. Next, we check if the current sum `currentSum` is greater than the current maximum sum `maxSum`.\n\t* If it is, we update `maxSum` with the new value of `currentSum`. This means we have found a new maximum subarray sum.\n5. If the current sum `currentSum` becomes negative, it indicates that including the current element in the subarray would reduce the overall sum. In such cases, we reset `currentSum` to 0\\. This effectively discards the current subarray and allows us to start a fresh subarray from the next element.\n6. We repeat steps 3 to 5 for each element in the array.\n7. After iterating through the entire array, the variable `maxSum` will contain the maximum subarray sum encountered.\n8. Finally, we return the value of `maxSum` as the result, representing the maximum sum of a contiguous subarray within the given array `nums`.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSum = float('-inf')\n        maxSum = float('-inf')\n        currentSum = 0\n        currentSum = 0\n        \n        for num in nums:\n        for num in nums:\n            currentSum += num\n            currentSum += num\n            \n            if currentSum > maxSum:\n            if currentSum > maxSum:\n                maxSum = currentSum\n                maxSum = currentSum\n            \n            if currentSum < 0:\n            if currentSum < 0:\n                currentSum = 0\n                currentSum = 0\n        \n        return maxSum        return maxSum\n```"
    },
    "54. Spiral Matrix": {
        "problem": "Given an `m x n` `matrix`, return all elements of the `matrix` in spiral order.\n",
        "explanation": "Approach:\n* We will use a while loop to traverse the matrix in a clockwise spiral order.\n* We will define four variables: left, right, top, bottom to represent the four boundaries of the current spiral.\n* We will use four for loops to traverse each edge of the current spiral in clockwise order and add the elements to the result list.\n* We will update the boundaries of the current spiral and continue the process until all elements have been traversed.\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix:\n        if not matrix:\n            return []\n            return []\n\n        rows, cols = len(matrix), len(matrix[0])\n        rows, cols = len(matrix), len(matrix[0])\n        top, bottom, left, right = 0, rows-1, 0, cols-1\n        top, bottom, left, right = 0, rows-1, 0, cols-1\n        result = []\n        result = []\n        \n        while len(result) < rows * cols:\n        while len(result) < rows * cols:\n            for i in range(left, right+1):\n            for i in range(left, right+1):\n                result.append(matrix[top][i])\n                result.append(matrix[top][i])\n            top += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n            for i in range(top, bottom+1):\n                result.append(matrix[i][right])\n                result.append(matrix[i][right])\n            right -= 1\n            right -= 1\n            \n            if top <= bottom:\n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                for i in range(right, left-1, -1):\n                    result.append(matrix[bottom][i])\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n                bottom -= 1\n            \n            if left <= right:\n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                for i in range(bottom, top-1, -1):\n                    result.append(matrix[i][left])\n                    result.append(matrix[i][left])\n                left += 1\n                left += 1\n        \n        return result\n        return result\n\n```"
    },
    "55. Jump Game": {
        "problem": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n",
        "explanation": "Approach\nWe have several ways to reach `goal`(\\= the last index) or `other index` from a current position, so my strategy is to move `goal` to left position if we meet a simple condition.\n\n\nThe condition is\n\n\n\n\n---\n\n\nâ­ï¸ Points\n\n\n\n```\nif current position + maximum jump >= goal\n```\n\n\n\n---\n\n\nIf we meet the condition we update `goal` with current index.\n\n\nLet's see how it works.\n\n\n\n```\nInput: nums = [2,3,1,1,4]\n```\n\nWe start at the second position from the last.\n\n\n\n```\n[2,3,1,1,4]\n       i g\n\ni = current position\ng = goal\n```\n\nLet's use the formula above.\n\n\n\n```\ncurrent position + maximum jump >= goal\n= 3 + 1 >= 4\n= true\n```\n\nWe can reach the current goal(\\= index `4`) from current position(\\= index `3`), **that means if we reach index `3`, we are sure that we can definitely reach the `goal`(\\= the last index).**\n\n\nThat's why we can move `goal` to index `3`.\n\n\nNext,\n\n\n\n```\n[2,3,1,1,4]\n     i g\n```\n\n\n```\ncurrent position + maximum jump >= goal\n= 2 + 1 >= 3\n= true\n```\n\nIf `true`, we are sure we can reach index `3` from index `2`. We know that if we reach index `3`, we can reach the last index, so update `goal` with index `2`. In the next time, if we can reach index `2`, that means we can reach the last index(\\= `4`)\n\n\nNext,\n\n\n\n```\n[2,3,1,1,4]\n   i g\n```\n\nI'll speed up.\n\n\n\n```\ncurrent position + maximum jump >= goal\n= 1 + 3 >= 2\n= true\n```\n\n\n```\n[2,3,1,1,4]\n i g\n```\n\n\n```\ncurrent position + maximum jump >= goal\n= 0 + 2 >= 1\n= true\n```\n\nIn the end,\n\n\n\n```\n[2,3,1,1,4]\n g\n```\n\nNow, `goal` is index `0`. That means we can reach the `goal` because we start from index `0`, so before we return `true` or `false`, we check this condition.\n\n\n\n```\nif goal == 0\n```\n\nIn this case\n\n\n\n```\nreturn true\n```\n\nEasy!ðŸ˜„  \n\nLet's see solution codes and step by step algorithm!\n\n\n\n\n---\n\n\nâ­ï¸ I recently created a video on how I've been using LeetCode to learn.\n\n\n\n\n\n---\n\n\n",
        "solution": "```python\nclass Solution:\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n    def canJump(self, nums: List[int]) -> bool:\n        goal = len(nums) - 1\n        goal = len(nums) - 1\n\n        for i in range(len(nums) - 2, -1, -1):\n        for i in range(len(nums) - 2, -1, -1):\n            if i + nums[i] >= goal:\n            if i + nums[i] >= goal:\n                goal = i\n                goal = i\n        \n        return True if goal == 0 else False        return True if goal == 0 else False\n```"
    },
    "56. Merge Intervals": {
        "problem": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non\\-overlapping intervals that cover all the intervals in the input.\n",
        "explanation": "Algorithm\nFirst, we sort the list as described. Then, we insert the first interval into our `merged` list and continue considering each interval in turn as follows: If the current interval begins *after* the previous interval ends, then they do not overlap and we can append the current interval to `merged`. Otherwise, they do overlap, and we merge them by updating the `end` of the previous interval if it is less than the `end` of the current interval.\n\n\nA simple proof by contradiction shows that this algorithm always produces the correct answer. First, suppose that the algorithm at some point fails to merge two intervals that should be merged. This would imply that there exists some triple of indices i, j, and k in a list of intervals ints such that i\\<j\\<k and (ints\\[i], ints\\[k]) can be merged, but neither (ints\\[i], ints\\[j]) nor (ints\\[j], ints\\[k]) can be merged. From this scenario follow several inequalities:\n\n\nints\\[i].end\\<ints\\[j].startints\\[j].end\\<ints\\[k].startints\\[i].endâ‰¥ints\\[k].startâ€‹\nWe can chain these inequalities (along with the following inequality, implied by the well\\-formedness of the intervals: ints\\[j].startâ‰¤ints\\[j].end) to demonstrate a contradiction:\n\n\nints\\[i].end\\<ints\\[j].startâ‰¤ints\\[j].end\\<ints\\[k].startints\\[i].endâ‰¥ints\\[k].startâ€‹\nTherefore, all mergeable intervals must occur in a contiguous run of the sorted list.\n\n\n![Sorting Example](../Figures/56/sort.png)\n\n\nConsider the example above, where the intervals are sorted, and then all mergeable intervals form contiguous blocks.\n\n\n\n**Complexity Analysis**\n\n\n* Time complexity : O(nlogn)\n\n\nOther than the `sort` invocation, we do a simple linear scan of the list, so the runtime is dominated by the O(nlogn) complexity of sorting.\n* Space complexity : O(logN) (or O(n))\n\n\nIf we can sort `intervals` in place, we do not need more than constant additional space, although the sorting itself takes O(logn) space. Otherwise, we must allocate linear space to store a copy of `intervals` and sort that.\n\n\\</ul",
        "solution": "```python\nclass Solution:\n    def overlap(self, a, b):\n        return a[0] <= b[1] and b[0] <= a[1]\n\n    # generate graph where there is an undirected edge between intervals u\n    # and v iff u and v overlap.\n    def buildGraph(self, intervals):\n        graph = collections.defaultdict(list)\n\n        for i, interval_i in enumerate(intervals):\n            for j in range(i + 1, len(intervals)):\n                if self.overlap(interval_i, intervals[j]):\n                    graph[tuple(interval_i)].append(intervals[j])\n                    graph[tuple(intervals[j])].append(interval_i)\n\n        return graph\n\n    # merges all of the nodes in this connected component into one interval.\n    def mergeNodes(self, nodes):\n        min_start = min(node[0] for node in nodes)\n        max_end = max(node[1] for node in nodes)\n        return [min_start, max_end]\n\n    # gets the connected components of the interval overlap graph.\n    def getComponents(self, graph, intervals):\n        visited = set()\n        comp_number = 0\n        nodes_in_comp = collections.defaultdict(list)\n\n        def markComponentDFS(start):\n            stack = [start]\n            while stack:\n                node = tuple(stack.pop())\n                if node not in visited:\n                    visited.add(node)\n                    nodes_in_comp[comp_number].append(node)\n\n\n        # mark all nodes in the same connected component with the same integer.\n        for interval in intervals:\n            if tuple(interval) not in visited:\n                markComponentDFS(interval)\n                comp_number += 1\n\n        return nodes_in_comp, comp_number\n```"
    },
    "57. Insert Interval": {
        "problem": "You are given an array of non\\-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.\n",
        "explanation": "Algorithm\n* If `intervals` is empty, it means there are no existing intervals, so we can simply return a array containing the `newInterval`.\n* Perform a binary search to find the correct position to insert the new interval in the `intervals` array. It updates the values of `left` and `right` based on the comparison of the target value with the first element of the interval at the middle index.\n\t+ Initialize the variables `target` with the starting point of `newInterval` (i.e., `newInterval[0]`), `left` with 0, and `right` with `n - 1` to define the search space in the `intervals` array.\n\t+ Perform a binary search by repeatedly dividing the search space in half until `left` is greater than `right`.\n\t+ Calculate the middle index `mid` as the average of `left` and `right`.\n\t+ If the start of the interval at index `mid` is less than the target value, update `left` to `mid + 1` to search the right half of the search space. Otherwise, update `right` to `mid - 1` to search the left half of the search space.\n\t+ The search updates `left` and `right` until they converge to the correct position. Repeat until `left` is greater than `right`.\n* Use `intervals.insert(intervals.begin() + left, newInterval)` to insert the `newInterval` at the correct position.\n* Initialize an empty array `res` to store the result.\n* Iterate through the sorted intervals.\n\t+ Check if `res` is empty or if the end of the last interval in `res` is less than the start of the current interval. If either condition is true, add the current interval to `res`.\n\t+ If there is an overlap, update the endpoint of the last interval in `res` to cover the current interval. This step ensures that non\\-overlapping intervals are added directly, and overlapping intervals are merged.\n* The final merged and inserted intervals are stored in the `res` array, which is then returned.\n\n\n#### \n\n",
        "solution": "```python\nclass Solution:\n    def insert(\n        self, intervals: List[List[int]], newInterval: List[int]\n    ) -> List[List[int]]:\n        n = len(intervals)\n        i = 0\n        res = []\n\n        # Case 1: No overlapping before merging intervals\n        while i < n and intervals[i][1] < newInterval[0]:\n            res.append(intervals[i])\n            i += 1\n\n        # Case 2: Overlapping and merging intervals\n        while i < n and newInterval[1] >= intervals[i][0]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        res.append(newInterval)\n\n        # Case 3: No overlapping after merging newInterval\n        while i < n:\n            res.append(intervals[i])\n            i += 1\n\n        return res\n```"
    }
}